1
00:00:00,000 --> 00:00:06,800
Hello and welcome back. This is gonna be I guess episode 2. Well I started zero for

2
00:00:06,800 --> 00:00:13,040
indexing right so this will be episode 1. Welcome to episode 1 of the

3
00:00:13,040 --> 00:00:24,120
podcast. I just saw recently that there was kind of an uptick in people who

4
00:00:24,120 --> 00:00:30,440
are streaming and they hit alt tab or they have they just have things on their

5
00:00:30,440 --> 00:00:37,680
screen that they shouldn't have. You know everything from like home addresses,

6
00:00:37,680 --> 00:00:47,720
web searches, adult videos, the websites, you know and that sort of stuff. Just a

7
00:00:47,720 --> 00:00:54,000
lot of personal information that is just going out there and it's kind of a

8
00:00:54,000 --> 00:00:59,640
it's kind of a problem you know with people streaming a lot and exposing all

9
00:00:59,640 --> 00:01:06,240
this stuff and there's a lot of easy ways to combat these problems especially

10
00:01:06,240 --> 00:01:13,040
on Windows. Windows has a lot of tools for you to not fall prey to this to this

11
00:01:13,040 --> 00:01:19,440
I don't know what to call it these self-destructive problems. It could be

12
00:01:19,440 --> 00:01:27,920
out of laziness or whatever else but I have some some thoughts on how to solve

13
00:01:27,920 --> 00:01:32,240
that and just some things people can do when they're streaming and it's not even

14
00:01:32,240 --> 00:01:35,440
just streaming there's a lot of people who record videos. I've watched people

15
00:01:35,440 --> 00:01:39,760
who record videos and they think the the animations and the things moving around

16
00:01:39,760 --> 00:01:45,880
is fast enough to not worry about people seeing their address you know on a maps

17
00:01:45,880 --> 00:01:53,600
location or seeing their private messages with their with their wife in

18
00:01:53,600 --> 00:02:00,200
this case that I'm thinking of wife or husband or whoever else. So there's

19
00:02:00,200 --> 00:02:03,560
there's very easy things you can do whenever you're recording whenever you're

20
00:02:03,560 --> 00:02:08,480
streaming on Windows that'll solve this. So I'm going to start off with talking

21
00:02:08,480 --> 00:02:13,160
about those things just some tools that you can use to to not fall prey to that

22
00:02:13,160 --> 00:02:17,440
and then the second part I'm going to talk a little bit about programming

23
00:02:17,440 --> 00:02:25,400
mainly about optimizing and making your code a bit faster and just things to

24
00:02:25,400 --> 00:02:31,840
think about I guess. So staying private while you're streaming one of the most

25
00:02:31,840 --> 00:02:38,800
common things that people do is the alt tab and alt tab is nice it allows you

26
00:02:38,800 --> 00:02:44,000
get through things really quickly. Let me suggest to you alt escape let's say that

27
00:02:44,000 --> 00:02:48,200
you have two windows you can put the window that you want to kind of look at

28
00:02:48,200 --> 00:02:52,680
on the screen behind the game and put your other stuff on the other monitor

29
00:02:52,680 --> 00:02:59,280
and you use alt escape to go to the background window and then come back to

30
00:02:59,280 --> 00:03:05,240
foreground so it's kind of like going through them in that way it just allows

31
00:03:05,240 --> 00:03:11,560
you to simply switch between it basically sends the current program to

32
00:03:11,560 --> 00:03:15,040
the back of the stack and the next one shows up so if there's only two you're

33
00:03:15,040 --> 00:03:20,360
just gonna be swapping between the two. So that's just a quick alternative if

34
00:03:20,360 --> 00:03:26,520
you're kind of wanting that that velocity of alt tab but of course we

35
00:03:26,520 --> 00:03:29,400
have lots of tabs we want to tab through them and we want to find the one that

36
00:03:29,400 --> 00:03:36,000
we're interested in. So the next thing that you'd want to do is virtual

37
00:03:36,000 --> 00:03:41,760
desktops. Not many people I've seen through their streams or anything like

38
00:03:41,760 --> 00:03:46,200
that use virtual desktops they kind of just stick everything about them up on

39
00:03:46,200 --> 00:03:53,920
their primary window. So I like to use virtual desktops to separate out this

40
00:03:53,920 --> 00:03:58,080
stuff and the great thing about virtual desktops is that you can shut down your

41
00:03:58,080 --> 00:04:00,800
computer you can restart your computer and it'll come back up and you'll still

42
00:04:00,800 --> 00:04:06,960
have your virtual desktop so you don't have to reset them up. In fact here's a

43
00:04:06,960 --> 00:04:14,400
example of what it looks like we have I have a primary desktop here and I got a

44
00:04:14,400 --> 00:04:19,480
podcast desktop here you can guess which one I'm using right now. So the primary

45
00:04:19,480 --> 00:04:24,320
one is gonna have you know chats and that sort of stuff on it and then the

46
00:04:24,320 --> 00:04:28,080
podcast one is gonna have podcast related things. The great thing about

47
00:04:28,080 --> 00:04:33,720
this is when you alt tab you're presented with just the programs that

48
00:04:33,720 --> 00:04:38,920
are running on that desktop so in this way you don't have to do much you can

49
00:04:38,920 --> 00:04:43,080
just set up these you can even give them a name as you saw just right click it

50
00:04:43,080 --> 00:04:51,720
hit rename there you go. Another problem that people have is browser tabs lots of

51
00:04:51,720 --> 00:04:55,560
lots of browser tabs also when you type in the browser it shows history of your

52
00:04:55,560 --> 00:05:00,760
searches I don't want to know what kind of weird things you search for but I am

53
00:05:00,760 --> 00:05:05,720
only human so when I see that pop up a little nagging part of the back my brain

54
00:05:05,720 --> 00:05:10,640
is like what's in there what are they what are they interested in not in a

55
00:05:10,640 --> 00:05:14,520
nefarious way but you know people you like to watch they have some information

56
00:05:14,520 --> 00:05:20,720
on things you wonder where they're getting it from so it's very tempting

57
00:05:20,720 --> 00:05:25,880
for a lot of people. People are curious by nature and they're going to wind up

58
00:05:25,880 --> 00:05:31,640
looking through that stuff that pops up especially if you have tabs search

59
00:05:31,640 --> 00:05:40,200
history all that sort of stuff. So how do we solve this if you're a gamer you can

60
00:05:40,200 --> 00:05:45,120
use the Steam browser I think you press shift tab and that'll open up the the

61
00:05:45,120 --> 00:05:48,440
Steam overlay and you hit web browser and you can search on stuff in there and

62
00:05:48,440 --> 00:05:52,400
that's a kind of an easier way for people that don't want to hold tab out

63
00:05:52,400 --> 00:05:57,600
or anything like that. The other one is to use browser sessions this is something

64
00:05:57,600 --> 00:06:03,400
I use quite often as you can see I have a few sessions here so when you're in

65
00:06:03,400 --> 00:06:06,560
your browser there's a little icon in the top right and you click on it and

66
00:06:06,560 --> 00:06:10,800
create you'll basically get this window with the sessions so you see I have my

67
00:06:10,800 --> 00:06:15,680
personal one I have one that is explicitly for Google things only I have

68
00:06:15,680 --> 00:06:21,720
one that's for the podcast I have one for Japanese stuff so you can guess that

69
00:06:21,720 --> 00:06:26,360
I'll be using podcast one whenever I'm going through this and so the podcast

70
00:06:26,360 --> 00:06:31,840
they have their separate histories they have their separate logins and you know

71
00:06:31,840 --> 00:06:38,000
data and plugins and everything else so separate out your separate

72
00:06:38,000 --> 00:06:42,320
separate out your browser stuff don't don't go streaming with your main

73
00:06:42,320 --> 00:06:47,920
browser and you know bank tabs open and all that sort of stuff so yeah it's very

74
00:06:47,920 --> 00:06:51,240
easy just set these up and you can you can decorate them you just hit the add

75
00:06:51,240 --> 00:06:56,720
button you can add as many as you want very simple so that's kind of how you

76
00:06:56,720 --> 00:07:01,680
can separate your browser how you separate your desktops one of the

77
00:07:01,680 --> 00:07:06,760
problems that you'll have with even if you separate out your desktops is you're

78
00:07:06,760 --> 00:07:11,120
gonna have your file system if you are a programmer and you're doing a programming

79
00:07:11,120 --> 00:07:18,920
video or a dev log or whatever you're gonna show your file system so it's just

80
00:07:18,920 --> 00:07:24,520
inevitable you have a file window open or you know you'll have files that you

81
00:07:24,520 --> 00:07:28,920
have to load up or something like that so if you want to show off that stuff I

82
00:07:28,920 --> 00:07:35,480
think we all use git we all use you know subversion I guess or perforce or you

83
00:07:35,480 --> 00:07:42,680
know all the different kinds of repositories so we can clone that stuff

84
00:07:42,680 --> 00:07:47,120
over to a separate user account it's very easy to create a separate user

85
00:07:47,120 --> 00:07:52,280
account I create one for family members I create them for just random stuff I

86
00:07:52,280 --> 00:07:57,200
want to lock myself out from or if I want to sandbox and like test around

87
00:07:57,200 --> 00:08:02,480
with things but you can create a user and then do all your videos and your

88
00:08:02,480 --> 00:08:06,760
streaming in that user you know if you're a big game streamer you just

89
00:08:06,760 --> 00:08:14,000
create a this is my game streaming account and you set up a user and it has

90
00:08:14,000 --> 00:08:17,240
its own file system and you can lock it out of access from your main file system

91
00:08:17,240 --> 00:08:22,800
so in that way you can prevent showing off your files whatever files you may

92
00:08:22,800 --> 00:08:29,680
have you know court subpoenas or whatever yeah they they'll now be kind

93
00:08:29,680 --> 00:08:34,960
of hidden away especially if you use the preview I sometimes use preview instead

94
00:08:34,960 --> 00:08:37,320
of Explorer and you know you accidentally click on something it'll

95
00:08:37,320 --> 00:08:40,480
show you preview on the right and you don't want that going up on your stream

96
00:08:40,480 --> 00:08:48,080
or you know up in your video and you didn't notice so creating a user account

97
00:08:48,080 --> 00:08:52,760
super easy you just go into your settings you look for accounts and

98
00:08:52,760 --> 00:08:56,960
there's other user accounts right here you just click add account very easy I

99
00:08:56,960 --> 00:09:01,440
don't think you have to have a Microsoft account for this for these you can add

100
00:09:01,440 --> 00:09:05,440
it as a family member I don't know just add an account and it's very simple and

101
00:09:05,440 --> 00:09:11,640
that'll make it so that you can separate out your file system and this will also

102
00:09:11,640 --> 00:09:14,840
make it so that you don't need virtual desktops or have to make different

103
00:09:14,840 --> 00:09:22,440
browser stuff so this is just another vector of attack for hiding you know not

104
00:09:22,440 --> 00:09:29,040
hiding but you know not not displaying your goods to the world there's a lot of

105
00:09:29,040 --> 00:09:32,960
important stuff on our computers and we have a lot of computers with a lot of

106
00:09:32,960 --> 00:09:36,000
stuff strung around that we don't even notice especially when we're clicking

107
00:09:36,000 --> 00:09:41,720
around real fast and a lot of people when they edit their videos they'll just

108
00:09:41,720 --> 00:09:46,800
load up their video and they'll skip ahead and you'll just miss those flashes

109
00:09:46,800 --> 00:09:52,440
of frames that pop up with sensitive information so please use user accounts

110
00:09:52,440 --> 00:10:01,040
if you need to protect your file system and those sort of things so another kind

111
00:10:01,040 --> 00:10:05,920
of thing that you can do is Windows Sandbox unfortunately you need to have

112
00:10:05,920 --> 00:10:09,840
Windows Pro your BIOS has to allow for virtualization you need to have it on in

113
00:10:09,840 --> 00:10:15,440
your BIOS and I think you need to have Hyper-V set up so there's a lot of

114
00:10:15,440 --> 00:10:18,920
prerequisites to this and it may cost money if you don't have Windows

115
00:10:18,920 --> 00:10:24,680
Pro so this is kind of for the other people that have Windows Pro and all

116
00:10:24,680 --> 00:10:31,920
the virtualization enabled in this one it's very simple you have apps and

117
00:10:31,920 --> 00:10:35,880
features just search features it'll show up apps and features here and then

118
00:10:35,880 --> 00:10:42,000
you'll have a list of features I suggest you turn on Windows subsystem for Linux

119
00:10:42,000 --> 00:10:46,400
as well if you're a developer and if you're watching this you probably are so

120
00:10:46,400 --> 00:10:51,600
turn that guy on if you don't already anyways Windows Sandbox is right there

121
00:10:51,600 --> 00:10:57,360
you turn that on restart your computer you'll be good to go and I guess I can I

122
00:10:57,360 --> 00:11:04,600
can show sandbox another problem I had with sandbox is once I installed it I

123
00:11:04,600 --> 00:11:10,200
could type in sandbox and it doesn't show up in all my apps so I actually

124
00:11:10,200 --> 00:11:17,480
have to go and go to all apps and then scroll all the way down to the W I'm

125
00:11:17,480 --> 00:11:23,600
actually gonna pin it pin to start you'll find in there just pin it or open

126
00:11:23,600 --> 00:11:31,320
it from from that and that will open up this Windows Sandbox and you'll see that

127
00:11:31,320 --> 00:11:35,520
it's just a regular old Windows looking instance I think I can scale this down

128
00:11:35,520 --> 00:11:41,400
so that it'll fit on the screen here there we go so you'll see it looks like

129
00:11:41,400 --> 00:11:45,920
a regular Windows instance you can set up a configuration file so that this can

130
00:11:45,920 --> 00:11:51,320
have access to certain folders when it launches which is nice you can make it

131
00:11:51,320 --> 00:11:56,480
run programs at startup which is also nice if you want to install stuff that

132
00:11:56,480 --> 00:12:00,600
sort of thing and then of course you can copy and paste from your primary desktop

133
00:12:00,600 --> 00:12:05,960
over into here so you can kind of set up your Windows Sandbox to present

134
00:12:05,960 --> 00:12:09,280
something or anything like that and this is a nice way to not have to make a user

135
00:12:09,280 --> 00:12:15,320
and also it's a nice way to clean out stuff if it's temporary and you're just

136
00:12:15,320 --> 00:12:20,680
showing off something and you don't want to keep all those files and it's it's

137
00:12:20,680 --> 00:12:24,480
just a waste of space and you don't have to clean them up yourself using the

138
00:12:24,480 --> 00:12:29,160
Windows Sandbox is cool because it destroys everything that's in its

139
00:12:29,160 --> 00:12:33,520
session of course it doesn't destroy the linked folders but if you put files and

140
00:12:33,520 --> 00:12:37,800
stuff in here on the desktop or in its own file system that's not the linked

141
00:12:37,800 --> 00:12:43,080
folders it will destroy them which is great especially if you're let's say

142
00:12:43,080 --> 00:12:50,160
that you're showing off something in your program and it installs or whenever

143
00:12:50,160 --> 00:12:55,400
you build it it makes like a makes like 30 gigs of files of assets or something

144
00:12:55,400 --> 00:12:59,000
it's really nice to have it in a sandbox so you just close it and not worry about

145
00:12:59,000 --> 00:13:03,320
it it's just gone once you hit that X you'll see you sure you want to kill

146
00:13:03,320 --> 00:13:05,960
sandbox yeah

147
00:13:07,160 --> 00:13:17,760
and for you if you're not interested in having people see all of your goods now

148
00:13:17,760 --> 00:13:22,800
I kind of did want to show what happens what people do instead of YouTube if you

149
00:13:22,800 --> 00:13:26,800
don't know this you know other web players have this and you probably do

150
00:13:26,800 --> 00:13:33,840
know this I'm sure a lot of developers know this but you can actually play

151
00:13:33,840 --> 00:13:42,840
frame-by-frame on a video so let's let's just let's just open up a video I have

152
00:13:42,840 --> 00:13:48,840
here and you'll see that I have it paused here and if I use the period key

153
00:13:48,840 --> 00:13:53,440
or the comma so the period a little forward a frame and the comma will go

154
00:13:53,440 --> 00:13:57,040
back a frame so I can press period period period so you can see I go

155
00:13:57,040 --> 00:14:05,480
frame-by-frame and view what's going on now I didn't want to bring up anybody's

156
00:14:05,480 --> 00:14:10,680
any of the particular videos that I've seen and I've seen a lot of them where

157
00:14:10,680 --> 00:14:17,560
you could just tell from one frame you can see the file system is exposed the

158
00:14:17,560 --> 00:14:21,360
browser tabs are shown all sorts of stuff is shown in one frame and they

159
00:14:21,360 --> 00:14:28,040
don't even notice it you very easily press pause and then just use the period

160
00:14:28,040 --> 00:14:35,880
and comma to go frame by frame to view this sensitive information and there are

161
00:14:35,880 --> 00:14:40,880
channels that are dedicated not dedicated there are channels that are

162
00:14:40,880 --> 00:14:45,760
kind of like reaction channels and they will very often use this this

163
00:14:45,760 --> 00:14:49,760
frame-by-frame feature to look at stuff in the background and comment on it or

164
00:14:49,760 --> 00:14:54,480
you know look at what's going on you know and their tabs and all this other

165
00:14:54,480 --> 00:15:01,360
stuff and they'll just comment on it as part of their gimmick so it's not just

166
00:15:01,360 --> 00:15:06,200
you know malicious actors who know how to do it there's a lot of YouTube

167
00:15:06,200 --> 00:15:10,960
channels that just promote this this frame swapping which is fine it's a

168
00:15:10,960 --> 00:15:16,840
fantastic feature like I've I've used it for animations when I watch some really

169
00:15:16,840 --> 00:15:21,720
cool animations online and I want to see how they they did the tweening or

170
00:15:21,720 --> 00:15:26,360
something like that I can use the the comma and the period to go back and

171
00:15:26,360 --> 00:15:30,480
forth the frame to kind of see how they they did the tweening and it's really

172
00:15:30,480 --> 00:15:36,800
nice it's a really nice feature honestly it's just in the wrong hands and with

173
00:15:36,800 --> 00:15:44,360
experienced video creators you'll find that they you know malicious people view

174
00:15:44,360 --> 00:15:48,560
it or as though you know it's maybe they're not malicious but it's just

175
00:15:48,560 --> 00:15:51,000
information they shouldn't know and shouldn't have in their head it's

176
00:15:51,000 --> 00:16:01,280
information for your head so that's kind of my perspective on on all of that sort

177
00:16:01,280 --> 00:16:06,440
of stuff now there is one more thing that you need to be aware of and this

178
00:16:06,440 --> 00:16:11,280
one is a lot has caught a lot more in people's videos but sometimes they're

179
00:16:11,280 --> 00:16:21,000
not and that's notifications so you'll get notifications on phones and you'll

180
00:16:21,000 --> 00:16:27,160
get notifications on in on Windows so if it's on the phone it's a little bit more

181
00:16:27,160 --> 00:16:30,480
difficult but if the phones on the desk and the cameras pointed in such a way

182
00:16:30,480 --> 00:16:38,320
that they can see it it'll be very easy to kind of see you see information there

183
00:16:38,320 --> 00:16:42,800
maybe it's hard because in the background is blurry but still you

184
00:16:42,800 --> 00:16:50,160
should just put on is it busy or you know yeah I think it's like busy on your

185
00:16:50,160 --> 00:16:55,000
phone where you it doesn't present any notifications turn that guy on if your

186
00:16:55,000 --> 00:16:58,480
phone is gonna be in the video or if you're reviewing phones or anything like

187
00:16:58,480 --> 00:17:02,560
that just if it's on the screen on a table in the back a lot of people have

188
00:17:02,560 --> 00:17:07,840
tables on the side or they put their phones and yeah it's it's not the

189
00:17:07,840 --> 00:17:14,720
greatest so just turn on busy or put it face down either one works and on

190
00:17:14,720 --> 00:17:21,120
Windows you can use quiet hours and it is important that you click it twice or

191
00:17:21,120 --> 00:17:25,320
quite time I don't always called is port you click it twice to alarms only

192
00:17:25,320 --> 00:17:29,680
because there is one that shows important notifications which may be

193
00:17:29,680 --> 00:17:38,360
work or emails or things like that so it's pretty easy you just hit on the

194
00:17:38,360 --> 00:17:42,600
down here where the little speaker thing is and the this is from a laptop so the

195
00:17:42,600 --> 00:17:46,680
little battery and the Ethernet just click on that and you click on this moon

196
00:17:46,680 --> 00:17:51,080
icon twice if it's not there then just hit this little pencil and add it hit it

197
00:17:51,080 --> 00:17:56,440
twice go to alarms only you're not gonna get any notifications a lot of this may

198
00:17:56,440 --> 00:18:01,520
be redundant for people but I've seen a lot of technical people don't follow

199
00:18:01,520 --> 00:18:09,880
these and it's just information that people shouldn't see so that's my rant

200
00:18:09,880 --> 00:18:17,000
on that that bothered me a lot recently it's happened way too many times and I

201
00:18:17,000 --> 00:18:22,680
also have a friend he's he's goofy anytime I put up a video and I'd like

202
00:18:22,680 --> 00:18:29,520
alt-tab that I'm just sending him for you know I trust him and all that you

203
00:18:29,520 --> 00:18:33,400
know he'll send me a screenshot be like what's that that sort of stuff and it's

204
00:18:33,400 --> 00:18:39,000
like a single frame so it's it's just part of human nature to be very curious

205
00:18:39,000 --> 00:18:43,680
on what's on people's computers and desktops what's in there it's kind of

206
00:18:43,680 --> 00:18:50,360
like you know there's a back room and the door is cracked slightly open pretty

207
00:18:50,360 --> 00:18:54,960
much everybody yeah who's who's not boring is gonna be you know trying to

208
00:18:54,960 --> 00:19:01,200
see creep over there and kind of peek or maybe even just ask her outright so yeah

209
00:19:01,200 --> 00:19:09,120
it's just something I thought needed a PSA but hopefully you follow all those

210
00:19:09,120 --> 00:19:17,040
so now I'm gonna talk about programming so part two I guess this is I don't know

211
00:19:17,040 --> 00:19:24,960
what to call it I think we'll call it it's very it's not groundbreaking but

212
00:19:24,960 --> 00:19:31,400
I'll call it grapevine coding it's where you hear something about how to program

213
00:19:31,400 --> 00:19:40,880
and you kind of take it as law of programming so programming back in the

214
00:19:40,880 --> 00:19:45,280
past may have been closer to that where there are paradigms that you can tell

215
00:19:45,280 --> 00:19:50,480
each other and they would be pretty reliable at being fast efficient saving

216
00:19:50,480 --> 00:19:55,960
size all those sorts of things and those paradigms first of all we're still using

217
00:19:55,960 --> 00:20:02,080
ones from three years ago three decades you'll still run into programmers who

218
00:20:02,080 --> 00:20:10,960
ask you know about these very old problems and that no longer exist so you

219
00:20:10,960 --> 00:20:17,240
kind of hear it on the grapevine and you you base your code and and and how you

220
00:20:17,240 --> 00:20:23,680
design your code on it which is even worse so one of the first things I want

221
00:20:23,680 --> 00:20:31,880
to mention is premature optimization we've all heard it we've all had leads

222
00:20:31,880 --> 00:20:37,520
we've all had friends who have said it preemus premature optimization is the

223
00:20:37,520 --> 00:20:44,200
root of all evil and they're quoting some guys from you know 60 years ago or

224
00:20:44,200 --> 00:20:50,800
so and they're guys I respect like Donald Knuth is it Knuth? Donald Knuth? I

225
00:20:50,800 --> 00:20:58,760
don't know I have his art of coding series it's like a big stack of books he

226
00:20:58,760 --> 00:21:07,040
kind of repeated it and one thing we need to realize is that quote was from

227
00:21:07,040 --> 00:21:12,400
the time of assembly and if anybody's programmed in assembly you know exactly

228
00:21:12,400 --> 00:21:16,200
what I'm talking about and you know exactly what they're talking about when

229
00:21:16,200 --> 00:21:21,480
they say premature optimization is the root of all evil because in assembly it's

230
00:21:21,480 --> 00:21:26,720
as programmers we can count the clock cycles and we can think oh man I if I

231
00:21:26,720 --> 00:21:30,680
can shave off a clock cycle here and a clock here you know I could do a cool

232
00:21:30,680 --> 00:21:37,280
effect or something or I can add I can have extra performance and those were

233
00:21:37,280 --> 00:21:43,600
very dangerous because you would design pretty pretty ridiculous code the code

234
00:21:43,600 --> 00:21:50,760
would be completely unreadable even with comments for assembly code and it's just

235
00:21:50,760 --> 00:21:54,440
awful to work in a team where parts of code you just don't understand

236
00:21:54,440 --> 00:22:02,000
especially if they're using some kind of hack or anything like that so it's that's

237
00:22:02,000 --> 00:22:10,800
kind of the root of it now that's propagated itself into modern era and in

238
00:22:10,800 --> 00:22:17,360
the modern era people use it for high-level languages now of course over

239
00:22:17,360 --> 00:22:22,960
optimization some early over optimization is not helpful on a team

240
00:22:22,960 --> 00:22:28,600
but you should always think about optimization as you're designing the

241
00:22:28,600 --> 00:22:32,440
code as part of your design not over optimization not ever you can't even

242
00:22:32,440 --> 00:22:37,400
really you can't even count clock cycles in a high-level language but you can

243
00:22:37,400 --> 00:22:40,120
think about how things are going to interact how slow they're going to be

244
00:22:40,120 --> 00:22:47,600
and so you really don't want to get that premature optimization is a root of all

245
00:22:47,600 --> 00:22:54,720
evil as like a base you want to work from in any project that is that is not

246
00:22:54,720 --> 00:23:00,440
good advice for high-level languages now the reason I say that is because

247
00:23:00,440 --> 00:23:04,800
high-level languages are much more easy to become spaghetti code you start

248
00:23:04,800 --> 00:23:09,880
adding a bunch of libraries your classes become super intertwined and is just

249
00:23:09,880 --> 00:23:14,640
almost impossible to undo things once they've get way too set in stone

250
00:23:14,640 --> 00:23:20,560
especially on a project where there's timelines involved and you've got

251
00:23:20,560 --> 00:23:24,080
project managers you're not going to get time to go back and rip out that whole

252
00:23:24,080 --> 00:23:29,240
thing to redo it so you do need to optimize those things up front and you

253
00:23:29,240 --> 00:23:32,520
need to think about the optimization you don't want to over optimize it it

254
00:23:32,520 --> 00:23:37,680
shouldn't be something that supports every test case scenario it should be

255
00:23:37,680 --> 00:23:43,920
something that supports the desired scenario and maybe design in a way that

256
00:23:43,920 --> 00:23:49,400
can extend it at minimal effort something like the visitor pattern is a

257
00:23:49,400 --> 00:23:54,520
great pattern for that sort of thing where the business logic comes into the

258
00:23:54,520 --> 00:23:58,040
system and it works off of that and you can swap out the business logic very

259
00:23:58,040 --> 00:24:04,960
easily so you do want to optimize ahead of time and that does want that should

260
00:24:04,960 --> 00:24:07,960
be something in the back of your mind you shouldn't just hack things in to get

261
00:24:07,960 --> 00:24:12,400
them going get them going quick you will regret it and it will waste a lot of

262
00:24:12,400 --> 00:24:18,520
your time and a lot of everybody else's time who has to use it and just to kind

263
00:24:18,520 --> 00:24:25,560
of show where I got this from this is actually a pretty nice book so let me

264
00:24:25,560 --> 00:24:33,520
set up my overhead camera here so we can look at it first of all it's from this

265
00:24:33,520 --> 00:24:38,240
book I like no scratch press this is a nice book thinking low-level writing

266
00:24:38,240 --> 00:24:44,960
high-level it's it's a kind of a thick book I have their x86 assembly x64

267
00:24:44,960 --> 00:24:49,680
assembly and a couple others of their books because they're they're nice I

268
00:24:49,680 --> 00:24:55,200
don't read books from start to finish so at programming books I don't read

269
00:24:55,200 --> 00:25:03,880
programming books from start to finish so that's definitely kind of one thing

270
00:25:03,880 --> 00:25:08,520
to keep in mind



271
00:25:08,520 --> 00:25:20,240
Just a moment, I've got to set up this overhead camera. Let's see. Okay, pretty sure I got

272
00:25:20,240 --> 00:25:27,440
it set up here. Let me move my keyboard out of the way. Thinking low-level, writing high-level.

273
00:25:27,440 --> 00:25:35,720
I just want to show you kind of where I got this. I've kind of always thought this, but

274
00:25:35,720 --> 00:25:45,840
it was put nicely into words in this book here. Let's see if we can't get a little bit

275
00:25:45,840 --> 00:25:54,880
of a zoom. There we go. So it actually talks about this here. Let's see. Although it's

276
00:25:54,880 --> 00:26:04,120
often attributed to Donald Knuth, who popularized it, Tony Hoare, another fantastic computer

277
00:26:04,120 --> 00:26:10,800
scientist, who said, premature optimization is the root of all evil. This has been a rallying

278
00:26:10,800 --> 00:26:15,800
cry of software engineers for application performance until the very end of time. However,

279
00:26:15,800 --> 00:26:21,920
it did not say concern with application performance during the early stages of application development

280
00:26:21,920 --> 00:26:29,040
is the root of all evil. And that's kind of the important part there. It was in a time

281
00:26:29,040 --> 00:26:34,720
of counting clock cycles. If you've done assembly programming, like I said, it's very tempting

282
00:26:34,720 --> 00:26:39,720
to count clock cycles. And I've done that quite a few times, and it's always bit me

283
00:26:39,720 --> 00:26:46,920
in the butt. And the people I code with on that, they regretted it. They were upset at

284
00:26:46,920 --> 00:26:56,040
me. So that's the book. I highly recommend it. I wouldn't go, I don't know how much this

285
00:26:56,040 --> 00:27:01,720
book was. It was kind of expensive. It's like $50. I don't know what it is now. But maybe

286
00:27:01,720 --> 00:27:08,520
if you can pick up a used copy, thumb through it, it's a pretty nice book. I like the no

287
00:27:08,520 --> 00:27:21,040
scratch press books. They're pretty sweet. So I'll put that back down here. So that's

288
00:27:21,040 --> 00:27:31,600
my long-winded part of premature optimizations. And I agree with the book. So let me turn

289
00:27:31,600 --> 00:27:46,440
off this phone. Okay. So that's part one, premature optimizations. So now that we've

290
00:27:46,440 --> 00:27:58,360
said that part, I'm going to counter that a little bit. That isn't a free pass to over-optimize

291
00:27:58,360 --> 00:28:09,480
all the time. Here's another example of programming and doing premature optimizations. So this

292
00:28:09,480 --> 00:28:18,640
is an example of something I did in my C library for my game engine. I was doing UTF-8 strings.

293
00:28:18,640 --> 00:28:27,800
And in those strings, I kind of put it, I knew I could go online and check out how other

294
00:28:27,800 --> 00:28:32,160
people have dealt with getting the length of the strings and all that sort of stuff

295
00:28:32,160 --> 00:28:36,840
and validating the strings. And I went online and I saw that, oh, it has tons of if statements.

296
00:28:36,840 --> 00:28:48,480
It has like four if statements just inside of a loop to determine if the UTF-8 string,

297
00:28:48,480 --> 00:28:54,040
to figure out its length, how many characters are in it. And for me, I was like, well, branching

298
00:28:54,040 --> 00:29:05,280
is not very good. All that branching is going to cost you in the long run. So I set up for

299
00:29:05,280 --> 00:29:16,400
myself a solution to the problem. Okay. I had to set up my web pages there. But I set

300
00:29:16,400 --> 00:29:25,600
up what I thought was a solution to the problem, I should say. And it was not, it did work.

301
00:29:25,600 --> 00:29:37,120
It was indeed faster. So this is my website. I had a little UTF-8 thing here. And you can

302
00:29:37,120 --> 00:29:42,040
see that I don't use any if statements. It's all just shifting logic and multiplication

303
00:29:42,040 --> 00:29:47,640
and addition, which can vectorize. It's not vectorized here because I'm not going to assume

304
00:29:47,640 --> 00:29:56,720
people are going to turn on vectorization. But here it's set up and then I have a validation

305
00:29:56,720 --> 00:30:04,560
function below that. So when I go to, when I went to run it, you'll see that it did go

306
00:30:04,560 --> 00:30:12,000
faster. It was 1.4 times faster than the internet common, or my previous attempt, I should say.

307
00:30:12,000 --> 00:30:24,080
And I do have the internet common one somewhere as well. Let me double check here. Okay. Unfortunately,

308
00:30:24,080 --> 00:30:28,320
I don't have the previous one. I do have one that I worked on a little bit. It did have

309
00:30:28,320 --> 00:30:32,680
a couple of if statements in it. This was like my first attempt at messing with it.

310
00:30:32,680 --> 00:30:42,280
And that one was 1.6 times faster than the, I guess it's five cases in the common internet

311
00:30:42,280 --> 00:30:51,160
one. So you can see that I can, I got faster than even one that was faster than that. 1.4

312
00:30:51,160 --> 00:30:59,520
times faster than that. Now, one of the problems I had was as the string scaled and it repeated

313
00:30:59,520 --> 00:31:06,200
itself, the internet common one, which is the one with all of the if statements, wound

314
00:31:06,200 --> 00:31:14,360
up being faster than my implementation without any if statements inside of the loop. And

315
00:31:14,360 --> 00:31:20,160
that's very, you know, surprising for anyone that, you know, talks about branching being

316
00:31:20,160 --> 00:31:30,320
very slow. Now I could try and run it. I do have the updated version here. But my problem

317
00:31:30,320 --> 00:31:37,640
is that the benchmarking software or website that I'm using here stopped working today,

318
00:31:37,640 --> 00:31:43,720
I think. So let's try to run it. I'm just going to paste it in here and then let's use

319
00:31:43,720 --> 00:31:50,240
cling 14. That's the one I used for my C++ engine. I'm going to run the benchmark. I'm

320
00:31:50,240 --> 00:31:54,840
not going to make you wait for this. I'm going to pause and see if it breaks. Okay. Yep,

321
00:31:54,840 --> 00:32:00,720
it's still broken. But you can take my word on it. When it was a short string or a string

322
00:32:00,720 --> 00:32:07,760
of random characters, I would see that my implementation was a little bit faster or

323
00:32:07,760 --> 00:32:12,080
quite a bit faster depending on the scenario. But when it was a really long string of repeating

324
00:32:12,080 --> 00:32:21,720
characters, the one with many if else branches wouldn't work. And this isn't even the right

325
00:32:21,720 --> 00:32:28,480
one. It's supposed to be this one. Anyways, it doesn't matter. It doesn't work anyways.

326
00:32:28,480 --> 00:32:33,420
So there goes against the conventional logic. Of course, the reasoning for this is that

327
00:32:33,420 --> 00:32:41,240
whenever it's a repeating string, the CPU, and this is modern CPU, I'm assuming, that

328
00:32:41,240 --> 00:32:49,000
is running on these cloud servers that this is hosted on, it detected the pattern and

329
00:32:49,000 --> 00:32:58,680
it did the branch selection much more efficiently. The other alternative is that the compiler

330
00:32:58,680 --> 00:33:03,880
saw the pattern. And since it's a very common pattern for UTF-8, the compiler optimized

331
00:33:03,880 --> 00:33:10,680
the code to a better performing UTF-8 function in assembly code. And so the compiler is kind

332
00:33:10,680 --> 00:33:24,200
of in the way there. Or useful? Useful in my way for my test, but useful overall.

333
00:33:24,200 --> 00:33:32,960
So essentially that's one of the things about tribal knowledge. The tribal knowledge of

334
00:33:32,960 --> 00:33:38,400
this will go faster if you remove the branches is not always true. So you don't want to just

335
00:33:38,400 --> 00:33:43,600
remove if statements to make it faster. Now, I do use my version of UTF-8 because it's

336
00:33:43,600 --> 00:33:48,120
better in most scenarios and it looks nicer to me. I think it looks pretty. It's better

337
00:33:48,120 --> 00:33:56,320
in a bunch of if-else cases. But that kind of shows you that you really do need to test

338
00:33:56,320 --> 00:34:06,200
on your hardware. There's nothing beyond testing on your target hardware.

339
00:34:06,200 --> 00:34:12,280
Now I've talked a lot about kind of just general things of optimization early. Over-optimizing

340
00:34:12,280 --> 00:34:19,680
doesn't always work. But now I want to talk about ways that you can improve your code

341
00:34:19,680 --> 00:34:28,840
on any system that either has these features or some features they have to have, like memory

342
00:34:28,840 --> 00:34:36,160
stuff. But these are surefire ways to improve the performance of your code. They are, you

343
00:34:36,160 --> 00:34:43,360
know, kind of like magic bullets. Basically, it's hard to go wrong with them unless you

344
00:34:43,360 --> 00:34:51,080
really don't know what you're doing. The first one is turn on the MMX or AVX or SIMD or for

345
00:34:51,080 --> 00:35:05,360
Android turn on NEON with flags like in Clang I think on Linux it's minus M-A-V-X. On Windows

346
00:35:05,360 --> 00:35:11,160
you can set it in Visual Studio. But turn those on and the compiler itself is going

347
00:35:11,160 --> 00:35:16,920
to vectorize. And vectorization, if you don't know what it is, SIMD stands for simultaneous

348
00:35:16,920 --> 00:35:24,640
instruction, multiple data. Essentially, you can provide lots of numbers and it can run,

349
00:35:24,640 --> 00:35:33,440
say, an ADD instruction in one of, it's not a single clock cycle, but in one of its virtual

350
00:35:33,440 --> 00:35:44,680
clocks for that. And so it will run in one instruction. So, you're not always going to

351
00:35:44,680 --> 00:35:48,840
know exactly what to do. It will try to vectorize where it can. It'll do it pretty efficiently

352
00:35:48,840 --> 00:35:54,860
in the standard libraries. So you will get some magic performance even if it's a little

353
00:35:54,860 --> 00:36:01,120
bit out of turning on vectorization. You can code vectorization yourself and it's not that

354
00:36:01,120 --> 00:36:09,440
difficult. The part that's annoying is that Android NEON uses something different than

355
00:36:09,440 --> 00:36:17,800
the standard AVX, MMX stuff. So you do have to if else case some of those things. The

356
00:36:17,800 --> 00:36:28,640
other problem is that on desktops you have access to doubles, larger, like a 256 byte

357
00:36:28,640 --> 00:36:35,520
vector. Whereas in Android NEON, I think you're limited to 128 byte vector. So you can't use

358
00:36:35,520 --> 00:36:41,680
like doubles, I mean you can do doubles, but you can't do, say, four doubles all together.

359
00:36:41,680 --> 00:36:46,680
You can do two, which is basically four floats. So there are some gotchas on that, depending

360
00:36:46,680 --> 00:36:52,440
on your platform. So it is a little annoying to support both. But you can write your code

361
00:36:52,440 --> 00:36:57,520
for this. And I wrote my own math library for my game engine. So all the vector math

362
00:36:57,520 --> 00:37:05,160
and all the matrix math, the whole shebang, I wrote by hand in C. And I used SIMD instructions

363
00:37:05,160 --> 00:37:16,240
to make it faster on desktop and make it faster on Android. Any CPUs that support those simultaneous

364
00:37:16,240 --> 00:37:23,440
instructions. So that's one way that you can, it's like a little magic bullet sometimes.

365
00:37:23,440 --> 00:37:27,280
You won't see much performance at all. And other times you can get some pretty big performance

366
00:37:27,280 --> 00:37:37,080
based on what you're doing. The other kind of magic bullet for making things faster is

367
00:37:37,080 --> 00:37:43,520
caching a lot of stuff. So of course, access to memory is slow, but caching things that

368
00:37:43,520 --> 00:37:49,880
are complicated or big structures, you know, if you're reading a file from a disk, whether

369
00:37:49,880 --> 00:37:54,480
it's binary or text, you've got to go read the file, do some stuff with it, read the

370
00:37:54,480 --> 00:37:59,720
file again later on. I don't know when, how often you do this. But if you were to load

371
00:37:59,720 --> 00:38:04,680
that into memory and just hold it in memory, just hold more in memory and not have to access

372
00:38:04,680 --> 00:38:14,720
it from the network or from file systems or, you know, kind of just those just elsewhere,

373
00:38:14,720 --> 00:38:20,720
you will gain performance. And of course, don't overdo it. Don't put your, I mean, we

374
00:38:20,720 --> 00:38:26,280
do that now. I think Unreal does that. It loads basically everything you need or as

375
00:38:26,280 --> 00:38:31,680
much as possible onto the GPU in this case, so that it can access it really quick.

376
00:38:31,680 --> 00:38:40,720
It is a very common practice to load up your memory with stuff you're going to use. That

377
00:38:40,720 --> 00:38:44,960
can go for shaders, it can go for GPU stuff, it can go for CPU if you're just processing

378
00:38:44,960 --> 00:38:53,720
data. Loading up that stuff into memory, caching things. In fact, one of the things, one of

379
00:38:53,720 --> 00:38:58,160
the software that you'll use in web is called Memcached or Memcached, I don't know how to

380
00:38:58,160 --> 00:39:04,440
say it, I'm pretty sure it's Memcached, where you can save things in a local cache or even,

381
00:39:04,440 --> 00:39:09,280
not even a local cache, it could be a remote cache, but it's all in memory, so it's much

382
00:39:09,280 --> 00:39:15,080
faster than a remote database and reading from the database, which reads from file system,

383
00:39:15,080 --> 00:39:24,120
even with SSDs. So, caching stuff in memory, kind of a magic bullet if you do it right.

384
00:39:24,120 --> 00:39:29,880
Checking your memory alignment. Some platforms like Raspberry Pi 3 will actually crash if

385
00:39:29,880 --> 00:39:36,200
you don't align your memory. So, some platforms force you to do this. But Intel, for the longest

386
00:39:36,200 --> 00:39:42,760
time, does not force you to align your memory. And aligning your memory properly will improve

387
00:39:42,760 --> 00:39:49,520
your performance, not significantly, but it is a nice performance boost. Reading data

388
00:39:49,520 --> 00:39:55,160
into structures, writing data, holding data, transferring data between multiple objects

389
00:39:55,160 --> 00:39:59,120
or cloning your data, it's going to be much faster, not much faster, it's going to be

390
00:39:59,120 --> 00:40:06,000
faster if you align your data properly. So, I think compilers have the option to align

391
00:40:06,000 --> 00:40:12,760
the memory for you, but it's not that hard to put an alignment in your structure. In

392
00:40:12,760 --> 00:40:21,600
fact, if you're using like Vulkan or Raspberry Pi 3, you do have to align your data structures

393
00:40:21,600 --> 00:40:25,800
to use it. So, in Vulkan, whenever you're setting up all your structures that interact

394
00:40:25,800 --> 00:40:31,520
with the Vulkan API, you align that data, because when it goes through the GPU, it expects

395
00:40:31,520 --> 00:40:37,480
to have a very specific alignment. So, it's not that much work, but it can gain you some

396
00:40:37,480 --> 00:40:47,000
performance. I don't think it's worth the effort most of the time, but it is probably

397
00:40:47,000 --> 00:40:55,720
a good practice to align your data. And then, aggregate commonly accessed data. I'm sure

398
00:40:55,720 --> 00:41:01,520
everybody's heard about this. They've heard about dots in Unity or, you know, what is

399
00:41:01,520 --> 00:41:05,840
it called? Entity component systems, stuff like that, where you have a system and then

400
00:41:05,840 --> 00:41:11,640
you have entities as an array and it accesses them, multiple enemies to the system. And

401
00:41:11,640 --> 00:41:17,560
it goes through this flow of accessing linear data, and that's much faster than accessing,

402
00:41:17,560 --> 00:41:23,840
say like a linked list. With a linked list, you have an object over there, an object over

403
00:41:23,840 --> 00:41:28,680
there, who knows where they're at. The memory is virtualized, so who knows where they're

404
00:41:28,680 --> 00:41:36,400
actually at in the physical memory. So, if you use, and by the way, like a linked list

405
00:41:36,400 --> 00:41:42,920
inside of lists, for example, inside of C Sharp are vectors, which are internally arrays.

406
00:41:42,920 --> 00:41:50,880
So, I'm talking about linked lists, when the data is disconnected. So, having your data,

407
00:41:50,880 --> 00:42:00,500
especially frequently accessed data, that is relative to each other in consecutive memory.

408
00:42:00,500 --> 00:42:05,600
If you want to do memory pooling and then have a big chunk of memory, and then, you

409
00:42:05,600 --> 00:42:13,880
know, virtualize your own addresses within that space, and you want to, say, put your

410
00:42:13,880 --> 00:42:17,280
entity for your game object in there, and its components and all that stuff that it

411
00:42:17,280 --> 00:42:23,480
has to access, you can put it in there. If you have a set of entities that all do the

412
00:42:23,480 --> 00:42:29,000
same thing, but they have individual datas, but you want to update them collectively,

413
00:42:29,000 --> 00:42:34,480
consecutively, you can use that memory pooling to kind of put them all in this consecutive

414
00:42:34,480 --> 00:42:40,680
memory. And knowing your CPU is good for this, because if you know how much cache you have

415
00:42:40,680 --> 00:42:45,840
on the CPU, you can actually optimize for cache, so that it'll load in a big old chunk,

416
00:42:45,840 --> 00:42:49,880
and it'll just blow through it really fast, and then you don't have to worry so much about

417
00:42:49,880 --> 00:42:56,320
your access to memory being slow. And that's the bottleneck of pretty much most programs

418
00:42:56,320 --> 00:43:00,880
outside of file system access and that sort of stuff, network stuff. So, aggregate your

419
00:43:00,880 --> 00:43:12,200
data together. That's one easy way to surefire, make your program faster.

420
00:43:12,200 --> 00:43:16,600
So those are some things you do to have magic bullets to solve a little bit of performance,

421
00:43:16,600 --> 00:43:21,560
but you're not going to make huge gains out of that. You're going to make little tiny

422
00:43:21,560 --> 00:43:27,200
gains, and it could be fun doing that sort of stuff. So there's no magic bullet for doubling

423
00:43:27,200 --> 00:43:31,840
your speed. Usually that just means fixing your overall algorithm, your business logic

424
00:43:31,840 --> 00:43:40,800
and how it operates. So even quantifiable algorithms that, you know, you've tested

425
00:43:40,800 --> 00:43:46,640
two algorithms and you've quantified mathematically, and one algorithm is better than the other,

426
00:43:46,640 --> 00:43:51,400
does not mean that it's going to run faster than the other, unless it leaps and bounds

427
00:43:51,400 --> 00:43:56,160
faster. If it's slightly faster, it does not mean it's going to run faster. Like I said,

428
00:43:56,160 --> 00:44:00,920
the CPUs are very smart. They figure out branching, they figure out caching and all that sort

429
00:44:00,920 --> 00:44:06,640
of stuff. So you can have a quantifiable, faster algorithm that will get beat by a slower

430
00:44:06,640 --> 00:44:12,400
algorithm just because of the architecture. So I really liked, you know, Game Boy or Xbox,

431
00:44:12,400 --> 00:44:17,360
PlayStation 3, you know, all those computers, Commodore 64, where they all have the same

432
00:44:17,360 --> 00:44:25,200
hardware and that means it's known and so you can test it very easily. Our problem nowadays

433
00:44:25,200 --> 00:44:29,960
is we have tons of different CPUs, tons of different iterations of CPUs, even along,

434
00:44:29,960 --> 00:44:35,800
like if you said, I support only Intel CPUs, there's tons of different Intel CPUs, you

435
00:44:35,800 --> 00:44:41,360
know, released every year and you don't know which one your players are going to be using

436
00:44:41,360 --> 00:44:49,480
or your clients are going to be using. So you don't really want to test and really hyper,

437
00:44:49,480 --> 00:44:56,760
make the performance hyper fast on a specific CPU, aka your development machine, at the

438
00:44:56,760 --> 00:45:04,000
cost of flexible code or readable code or elegant code or any of that. So it's just

439
00:45:04,000 --> 00:45:08,840
something to keep in mind. If you are using a very well-known, specific set of hardware,

440
00:45:08,840 --> 00:45:15,320
usually game consoles, more power to you. Just knock out that performance on that CPU

441
00:45:15,320 --> 00:45:21,000
because it's a known CPU that you can, you're programming against. Everybody, everyone who's

442
00:45:21,000 --> 00:45:28,040
going to play your game on that device has that device. So that's, you can optimize in

443
00:45:28,040 --> 00:45:38,280
those scenarios and just go whole ham for that. So yeah, just test specific hardware.

444
00:45:38,280 --> 00:45:44,920
If you have minimum requirements, suggested requirements, test on those guys, test the

445
00:45:44,920 --> 00:45:50,200
performance. You may very well find that one performs better in one scenario and worse

446
00:45:50,200 --> 00:45:58,600
in another. So that's kind of the thoughts on optimization. Now I do want to wrap this

447
00:45:58,600 --> 00:46:08,040
up with a famous optimization and I've been asked about this optimization. You know, it's

448
00:46:08,040 --> 00:46:13,920
something that a lot of people know because it's a very popular one. And this is the inverse,

449
00:46:13,920 --> 00:46:26,760
the fast inverse square root. You know, it's a 30-year-old square root that they did for,

450
00:46:26,760 --> 00:46:34,320
was it Doom or Quake? It was probably Quake. I don't know. John Carmack made it but he

451
00:46:34,320 --> 00:46:38,520
got it from someone else. I'm like, I don't know the history. History is not important.

452
00:46:38,520 --> 00:46:44,680
The fact is you shouldn't be using this. This is a 30-year-old algorithm made for the machines

453
00:46:44,680 --> 00:46:51,720
of the time which didn't have branch prediction, for example. And they didn't have built-in

454
00:46:51,720 --> 00:47:00,640
signs or they didn't have built-in square roots. Nowadays, we have built-in square roots.

455
00:47:00,640 --> 00:47:03,760
We have built-in square roots for floats. We have built-in square roots for doubles

456
00:47:03,760 --> 00:47:12,960
and they are single instruction on the CPU. So it's not worth our time to implement 30-year-old

457
00:47:12,960 --> 00:47:21,920
algorithms and computers change often. And it's just one thing that I do see developers

458
00:47:21,920 --> 00:47:28,140
getting caught up on is some of these, some of this old knowledge that doesn't really

459
00:47:28,140 --> 00:47:33,680
apply anymore. So I've got a little thing here we can take a look at. So if we take

460
00:47:33,680 --> 00:47:39,400
a look here at this code, we're including math. It's just a little C file. And we're

461
00:47:39,400 --> 00:47:46,240
going to do the square root float, square root double. And I'm just going to put a break

462
00:47:46,240 --> 00:47:50,400
point here. This is debug mode. Nothing is optimized because otherwise it will strip

463
00:47:50,400 --> 00:47:57,720
out the stuff and I don't want to fight the optimizer to show an example of something.

464
00:47:57,720 --> 00:48:01,880
So we're going to run this and what we're going to do here, I already have it open,

465
00:48:01,880 --> 00:48:08,200
but you can go to debug, windows, disassembly to see the assembly code that's generated

466
00:48:08,200 --> 00:48:17,920
for this program. And if we just look at the disassembly here, we can see that we have,

467
00:48:17,920 --> 00:48:22,400
this is the C code and these are the functions that are set up for it. I don't know exactly

468
00:48:22,400 --> 00:48:26,920
what it's going to be when you optimize the code. It may even strip the square root based

469
00:48:26,920 --> 00:48:31,440
on the cons that are going in and all that sort of stuff. But anyways, you can see here

470
00:48:31,440 --> 00:48:38,080
it uses implementation of square root F here, which is going to be an internal function

471
00:48:38,080 --> 00:48:43,640
that does magic things. But what you can see here for the square root of double is that

472
00:48:43,640 --> 00:48:52,040
it is a single built in assembly instruction. Well, it's calling this function. And this

473
00:48:52,040 --> 00:48:57,360
function, the reason it's calling this function is that vendors can implement it how they

474
00:48:57,360 --> 00:49:04,120
want. Most of them are going to implement it. You can see this is using XMM by the way.

475
00:49:04,120 --> 00:49:12,000
Most of the vendors are going to implement it the way that is fastest. So CPU calls,

476
00:49:12,000 --> 00:49:19,080
it's going to be based on the architecture. But this is going to be way, way faster than

477
00:49:19,080 --> 00:49:25,440
the inverse square root function from 30 years ago. So do not use that. And don't use knowledge

478
00:49:25,440 --> 00:49:34,480
from 30 years ago. Use wisdom from 30 years ago. Generally how you work with teams and

479
00:49:34,480 --> 00:49:41,280
how you work with code and how you design code and think about how things interact.

480
00:49:41,280 --> 00:49:44,800
That sort of stuff is super valuable. Those guys did a lot of research mainly in those

481
00:49:44,800 --> 00:49:50,700
fields. They didn't optimize these little instructions. And that is the useful information

482
00:49:50,700 --> 00:49:58,360
for you. Not inverse square root or any particular algorithm. If an algorithm has been used for

483
00:49:58,360 --> 00:50:04,160
30 years, take a look at maybe making a new algorithm. Because there's a lot of stuff

484
00:50:04,160 --> 00:50:11,360
that gets added to CPUs. We have now artificial intelligence parts of our CPUs. We've got

485
00:50:11,360 --> 00:50:19,240
matrix stacked CPUs. We've got all kinds of new stuff that can use a different algorithm

486
00:50:19,240 --> 00:50:26,640
and perform much faster. Say whether it's distributed across multiple cores. Or maybe

487
00:50:26,640 --> 00:50:32,080
you even use the GPU to do the algorithm. Because we do have compute GPU now. Like compute

488
00:50:32,080 --> 00:50:40,960
shaders or CUDA. You can just write an algorithm that runs across a huge amount of cores and

489
00:50:40,960 --> 00:50:49,480
blow through things way faster now. So that's kind of my general advice on optimization.

490
00:50:49,480 --> 00:50:58,520
Don't over optimize. But do think about optimizing ahead of time. And don't stress out. Have

491
00:50:58,520 --> 00:51:03,920
fun while coding. Think about it. Think more about your overall design. Who you're working

492
00:51:03,920 --> 00:51:10,120
with. Whether you're working alone or not. And just think about those aspects of your

493
00:51:10,120 --> 00:51:13,960
coding. And you're going to have a wonderful experience. And you're going to be much happier.

494
00:51:13,960 --> 00:51:18,040
And you're not going to get caught up in all the fights on stack overflow or whatever people

495
00:51:18,040 --> 00:51:24,760
do on stack overflow these days. So, cool. That's basically it. If you guys have any

496
00:51:24,760 --> 00:51:32,000
suggestions on things to take a look at or think about or talk about or anything like

497
00:51:32,000 --> 00:51:37,920
that. This has been quite a lot of fun. So, yeah. Let me know if I missed anything. If

498
00:51:37,920 --> 00:51:43,240
I messed up anything. If I got any information wrong. You know, if things have changed or

499
00:51:43,240 --> 00:51:49,560
maybe I just misinterpreted something. Let me know and we can always pin the comment

500
00:51:49,560 --> 00:51:55,000
so that other people know too. So, bye for now.

501
00:51:55,000 --> 00:52:01,400
Hello. This is an amendment to the podcast. You can tell that it's a different day. Sun's

502
00:52:01,400 --> 00:52:06,920
out and everything. But I was going to sleep last night and I realized that I said 256

503
00:52:06,920 --> 00:52:14,440
bytes for SIMD instructions and 128 bytes for the NEON instructions for ARM. And I meant

504
00:52:14,440 --> 00:52:19,000
to say bits. So, I don't know why that bugged me. Clearing that one up. Second one, the

505
00:52:19,000 --> 00:52:25,920
one that actually bothered me was the system calls to the square root functions. And that's

506
00:52:25,920 --> 00:52:31,360
because we were in debug mode and it was getting late and I wasn't thinking about it. So, I

507
00:52:31,360 --> 00:52:40,640
have now set up a release mode demo here where we will see the x86 instructions for square

508
00:52:40,640 --> 00:52:45,360
roots. So, you can see I have to print them out so that it doesn't optimize my variables

509
00:52:45,360 --> 00:52:51,280
out. And then if we run this and check out our disassembly, it will be in reverse order.

510
00:52:51,280 --> 00:52:55,920
The key is going to be up here. But you see it calls the assembly instruction square root

511
00:52:55,920 --> 00:53:04,760
PD and then square root single signed or signed single. I don't know which one of the S's

512
00:53:04,760 --> 00:53:11,760
is signed and which one is singled. But there you go. That's the actual assembly instructions

513
00:53:11,760 --> 00:53:16,400
I was expecting to see. I was a little bit surprised when I didn't see them last night.

514
00:53:16,400 --> 00:53:23,560
But it's because I was in debug mode. I wasn't thinking. So, yeah. And that's basically my

515
00:53:23,560 --> 00:53:26,000
amendment. See you guys.




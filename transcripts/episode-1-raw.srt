1
00:00:00,000 --> 00:00:06,800
Hello and welcome back. This is gonna be I guess episode 2. Well I started zero for

2
00:00:06,800 --> 00:00:13,040
indexing right so this will be episode 1. Welcome to episode 1 of the

3
00:00:13,040 --> 00:00:24,120
podcast. I just saw recently that there was kind of an uptick in people who

4
00:00:24,120 --> 00:00:30,440
are streaming and they hit alt tab or they have they just have things on their

5
00:00:30,440 --> 00:00:37,680
screen that they shouldn't have. You know everything from like home addresses,

6
00:00:37,680 --> 00:00:47,720
web searches, adult videos, the websites, you know and that sort of stuff. Just a

7
00:00:47,720 --> 00:00:54,000
lot of personal information that is just going out there and it's kind of a

8
00:00:54,000 --> 00:00:59,640
it's kind of a problem you know with people streaming a lot and exposing all

9
00:00:59,640 --> 00:01:06,240
this stuff and there's a lot of easy ways to combat these problems especially

10
00:01:06,240 --> 00:01:13,040
on Windows. Windows has a lot of tools for you to not fall prey to this to this

11
00:01:13,040 --> 00:01:19,440
I don't know what to call it these self-destructive problems. It could be

12
00:01:19,440 --> 00:01:27,920
out of laziness or whatever else but I have some some thoughts on how to solve

13
00:01:27,920 --> 00:01:32,240
that and just some things people can do when they're streaming and it's not even

14
00:01:32,240 --> 00:01:35,440
just streaming there's a lot of people who record videos. I've watched people

15
00:01:35,440 --> 00:01:39,760
who record videos and they think the the animations and the things moving around

16
00:01:39,760 --> 00:01:45,880
is fast enough to not worry about people seeing their address you know on a maps

17
00:01:45,880 --> 00:01:53,600
location or seeing their private messages with their with their wife in

18
00:01:53,600 --> 00:02:00,200
this case that I'm thinking of wife or husband or whoever else. So there's

19
00:02:00,200 --> 00:02:03,560
there's very easy things you can do whenever you're recording whenever you're

20
00:02:03,560 --> 00:02:08,480
streaming on Windows that'll solve this. So I'm going to start off with talking

21
00:02:08,480 --> 00:02:13,160
about those things just some tools that you can use to to not fall prey to that

22
00:02:13,160 --> 00:02:17,440
and then the second part I'm going to talk a little bit about programming

23
00:02:17,440 --> 00:02:25,400
mainly about optimizing and making your code a bit faster and just things to

24
00:02:25,400 --> 00:02:31,840
think about I guess. So staying private while you're streaming one of the most

25
00:02:31,840 --> 00:02:38,800
common things that people do is the alt tab and alt tab is nice it allows you

26
00:02:38,800 --> 00:02:44,000
get through things really quickly. Let me suggest to you alt escape let's say that

27
00:02:44,000 --> 00:02:48,200
you have two windows you can put the window that you want to kind of look at

28
00:02:48,200 --> 00:02:52,680
on the screen behind the game and put your other stuff on the other monitor

29
00:02:52,680 --> 00:02:59,280
and you use alt escape to go to the background window and then come back to

30
00:02:59,280 --> 00:03:05,240
foreground so it's kind of like going through them in that way it just allows

31
00:03:05,240 --> 00:03:11,560
you to simply switch between it basically sends the current program to

32
00:03:11,560 --> 00:03:15,040
the back of the stack and the next one shows up so if there's only two you're

33
00:03:15,040 --> 00:03:20,360
just gonna be swapping between the two. So that's just a quick alternative if

34
00:03:20,360 --> 00:03:26,520
you're kind of wanting that that velocity of alt tab but of course we

35
00:03:26,520 --> 00:03:29,400
have lots of tabs we want to tab through them and we want to find the one that

36
00:03:29,400 --> 00:03:36,000
we're interested in. So the next thing that you'd want to do is virtual

37
00:03:36,000 --> 00:03:41,760
desktops. Not many people I've seen through their streams or anything like

38
00:03:41,760 --> 00:03:46,200
that use virtual desktops they kind of just stick everything about them up on

39
00:03:46,200 --> 00:03:53,920
their primary window. So I like to use virtual desktops to separate out this

40
00:03:53,920 --> 00:03:58,080
stuff and the great thing about virtual desktops is that you can shut down your

41
00:03:58,080 --> 00:04:00,800
computer you can restart your computer and it'll come back up and you'll still

42
00:04:00,800 --> 00:04:06,960
have your virtual desktop so you don't have to reset them up. In fact here's a

43
00:04:06,960 --> 00:04:14,400
example of what it looks like we have I have a primary desktop here and I got a

44
00:04:14,400 --> 00:04:19,480
podcast desktop here you can guess which one I'm using right now. So the primary

45
00:04:19,480 --> 00:04:24,320
one is gonna have you know chats and that sort of stuff on it and then the

46
00:04:24,320 --> 00:04:28,080
podcast one is gonna have podcast related things. The great thing about

47
00:04:28,080 --> 00:04:33,720
this is when you alt tab you're presented with just the programs that

48
00:04:33,720 --> 00:04:38,920
are running on that desktop so in this way you don't have to do much you can

49
00:04:38,920 --> 00:04:43,080
just set up these you can even give them a name as you saw just right click it

50
00:04:43,080 --> 00:04:51,720
hit rename there you go. Another problem that people have is browser tabs lots of

51
00:04:51,720 --> 00:04:55,560
lots of browser tabs also when you type in the browser it shows history of your

52
00:04:55,560 --> 00:05:00,760
searches I don't want to know what kind of weird things you search for but I am

53
00:05:00,760 --> 00:05:05,720
only human so when I see that pop up a little nagging part of the back my brain

54
00:05:05,720 --> 00:05:10,640
is like what's in there what are they what are they interested in not in a

55
00:05:10,640 --> 00:05:14,520
nefarious way but you know people you like to watch they have some information

56
00:05:14,520 --> 00:05:20,720
on things you wonder where they're getting it from so it's very tempting

57
00:05:20,720 --> 00:05:25,880
for a lot of people. People are curious by nature and they're going to wind up

58
00:05:25,880 --> 00:05:31,640
looking through that stuff that pops up especially if you have tabs search

59
00:05:31,640 --> 00:05:40,200
history all that sort of stuff. So how do we solve this if you're a gamer you can

60
00:05:40,200 --> 00:05:45,120
use the Steam browser I think you press shift tab and that'll open up the the

61
00:05:45,120 --> 00:05:48,440
Steam overlay and you hit web browser and you can search on stuff in there and

62
00:05:48,440 --> 00:05:52,400
that's a kind of an easier way for people that don't want to hold tab out

63
00:05:52,400 --> 00:05:57,600
or anything like that. The other one is to use browser sessions this is something

64
00:05:57,600 --> 00:06:03,400
I use quite often as you can see I have a few sessions here so when you're in

65
00:06:03,400 --> 00:06:06,560
your browser there's a little icon in the top right and you click on it and

66
00:06:06,560 --> 00:06:10,800
create you'll basically get this window with the sessions so you see I have my

67
00:06:10,800 --> 00:06:15,680
personal one I have one that is explicitly for Google things only I have

68
00:06:15,680 --> 00:06:21,720
one that's for the podcast I have one for Japanese stuff so you can guess that

69
00:06:21,720 --> 00:06:26,360
I'll be using podcast one whenever I'm going through this and so the podcast

70
00:06:26,360 --> 00:06:31,840
they have their separate histories they have their separate logins and you know

71
00:06:31,840 --> 00:06:38,000
data and plugins and everything else so separate out your separate

72
00:06:38,000 --> 00:06:42,320
separate out your browser stuff don't don't go streaming with your main

73
00:06:42,320 --> 00:06:47,920
browser and you know bank tabs open and all that sort of stuff so yeah it's very

74
00:06:47,920 --> 00:06:51,240
easy just set these up and you can you can decorate them you just hit the add

75
00:06:51,240 --> 00:06:56,720
button you can add as many as you want very simple so that's kind of how you

76
00:06:56,720 --> 00:07:01,680
can separate your browser how you separate your desktops one of the

77
00:07:01,680 --> 00:07:06,760
problems that you'll have with even if you separate out your desktops is you're

78
00:07:06,760 --> 00:07:11,120
gonna have your file system if you are a programmer and you're doing a programming

79
00:07:11,120 --> 00:07:18,920
video or a dev log or whatever you're gonna show your file system so it's just

80
00:07:18,920 --> 00:07:24,520
inevitable you have a file window open or you know you'll have files that you

81
00:07:24,520 --> 00:07:28,920
have to load up or something like that so if you want to show off that stuff I

82
00:07:28,920 --> 00:07:35,480
think we all use git we all use you know subversion I guess or perforce or you

83
00:07:35,480 --> 00:07:42,680
know all the different kinds of repositories so we can clone that stuff

84
00:07:42,680 --> 00:07:47,120
over to a separate user account it's very easy to create a separate user

85
00:07:47,120 --> 00:07:52,280
account I create one for family members I create them for just random stuff I

86
00:07:52,280 --> 00:07:57,200
want to lock myself out from or if I want to sandbox and like test around

87
00:07:57,200 --> 00:08:02,480
with things but you can create a user and then do all your videos and your

88
00:08:02,480 --> 00:08:06,760
streaming in that user you know if you're a big game streamer you just

89
00:08:06,760 --> 00:08:14,000
create a this is my game streaming account and you set up a user and it has

90
00:08:14,000 --> 00:08:17,240
its own file system and you can lock it out of access from your main file system

91
00:08:17,240 --> 00:08:22,800
so in that way you can prevent showing off your files whatever files you may

92
00:08:22,800 --> 00:08:29,680
have you know court subpoenas or whatever yeah they they'll now be kind

93
00:08:29,680 --> 00:08:34,960
of hidden away especially if you use the preview I sometimes use preview instead

94
00:08:34,960 --> 00:08:37,320
of Explorer and you know you accidentally click on something it'll

95
00:08:37,320 --> 00:08:40,480
show you preview on the right and you don't want that going up on your stream

96
00:08:40,480 --> 00:08:48,080
or you know up in your video and you didn't notice so creating a user account

97
00:08:48,080 --> 00:08:52,760
super easy you just go into your settings you look for accounts and

98
00:08:52,760 --> 00:08:56,960
there's other user accounts right here you just click add account very easy I

99
00:08:56,960 --> 00:09:01,440
don't think you have to have a Microsoft account for this for these you can add

100
00:09:01,440 --> 00:09:05,440
it as a family member I don't know just add an account and it's very simple and

101
00:09:05,440 --> 00:09:11,640
that'll make it so that you can separate out your file system and this will also

102
00:09:11,640 --> 00:09:14,840
make it so that you don't need virtual desktops or have to make different

103
00:09:14,840 --> 00:09:22,440
browser stuff so this is just another vector of attack for hiding you know not

104
00:09:22,440 --> 00:09:29,040
hiding but you know not not displaying your goods to the world there's a lot of

105
00:09:29,040 --> 00:09:32,960
important stuff on our computers and we have a lot of computers with a lot of

106
00:09:32,960 --> 00:09:36,000
stuff strung around that we don't even notice especially when we're clicking

107
00:09:36,000 --> 00:09:41,720
around real fast and a lot of people when they edit their videos they'll just

108
00:09:41,720 --> 00:09:46,800
load up their video and they'll skip ahead and you'll just miss those flashes

109
00:09:46,800 --> 00:09:52,440
of frames that pop up with sensitive information so please use user accounts

110
00:09:52,440 --> 00:10:01,040
if you need to protect your file system and those sort of things so another kind

111
00:10:01,040 --> 00:10:05,920
of thing that you can do is Windows Sandbox unfortunately you need to have

112
00:10:05,920 --> 00:10:09,840
Windows Pro your BIOS has to allow for virtualization you need to have it on in

113
00:10:09,840 --> 00:10:15,440
your BIOS and I think you need to have Hyper-V set up so there's a lot of

114
00:10:15,440 --> 00:10:18,920
prerequisites to this and it may cost money if you don't have Windows

115
00:10:18,920 --> 00:10:24,680
Pro so this is kind of for the other people that have Windows Pro and all

116
00:10:24,680 --> 00:10:31,920
the virtualization enabled in this one it's very simple you have apps and

117
00:10:31,920 --> 00:10:35,880
features just search features it'll show up apps and features here and then

118
00:10:35,880 --> 00:10:42,000
you'll have a list of features I suggest you turn on Windows subsystem for Linux

119
00:10:42,000 --> 00:10:46,400
as well if you're a developer and if you're watching this you probably are so

120
00:10:46,400 --> 00:10:51,600
turn that guy on if you don't already anyways Windows Sandbox is right there

121
00:10:51,600 --> 00:10:57,360
you turn that on restart your computer you'll be good to go and I guess I can I

122
00:10:57,360 --> 00:11:04,600
can show sandbox another problem I had with sandbox is once I installed it I

123
00:11:04,600 --> 00:11:10,200
could type in sandbox and it doesn't show up in all my apps so I actually

124
00:11:10,200 --> 00:11:17,480
have to go and go to all apps and then scroll all the way down to the W I'm

125
00:11:17,480 --> 00:11:23,600
actually gonna pin it pin to start you'll find in there just pin it or open

126
00:11:23,600 --> 00:11:31,320
it from from that and that will open up this Windows Sandbox and you'll see that

127
00:11:31,320 --> 00:11:35,520
it's just a regular old Windows looking instance I think I can scale this down

128
00:11:35,520 --> 00:11:41,400
so that it'll fit on the screen here there we go so you'll see it looks like

129
00:11:41,400 --> 00:11:45,920
a regular Windows instance you can set up a configuration file so that this can

130
00:11:45,920 --> 00:11:51,320
have access to certain folders when it launches which is nice you can make it

131
00:11:51,320 --> 00:11:56,480
run programs at startup which is also nice if you want to install stuff that

132
00:11:56,480 --> 00:12:00,600
sort of thing and then of course you can copy and paste from your primary desktop

133
00:12:00,600 --> 00:12:05,960
over into here so you can kind of set up your Windows Sandbox to present

134
00:12:05,960 --> 00:12:09,280
something or anything like that and this is a nice way to not have to make a user

135
00:12:09,280 --> 00:12:15,320
and also it's a nice way to clean out stuff if it's temporary and you're just

136
00:12:15,320 --> 00:12:20,680
showing off something and you don't want to keep all those files and it's it's

137
00:12:20,680 --> 00:12:24,480
just a waste of space and you don't have to clean them up yourself using the

138
00:12:24,480 --> 00:12:29,160
Windows Sandbox is cool because it destroys everything that's in its

139
00:12:29,160 --> 00:12:33,520
session of course it doesn't destroy the linked folders but if you put files and

140
00:12:33,520 --> 00:12:37,800
stuff in here on the desktop or in its own file system that's not the linked

141
00:12:37,800 --> 00:12:43,080
folders it will destroy them which is great especially if you're let's say

142
00:12:43,080 --> 00:12:50,160
that you're showing off something in your program and it installs or whenever

143
00:12:50,160 --> 00:12:55,400
you build it it makes like a makes like 30 gigs of files of assets or something

144
00:12:55,400 --> 00:12:59,000
it's really nice to have it in a sandbox so you just close it and not worry about

145
00:12:59,000 --> 00:13:03,320
it it's just gone once you hit that X you'll see you sure you want to kill

146
00:13:03,320 --> 00:13:05,960
sandbox yeah

147
00:13:07,160 --> 00:13:17,760
and for you if you're not interested in having people see all of your goods now

148
00:13:17,760 --> 00:13:22,800
I kind of did want to show what happens what people do instead of YouTube if you

149
00:13:22,800 --> 00:13:26,800
don't know this you know other web players have this and you probably do

150
00:13:26,800 --> 00:13:33,840
know this I'm sure a lot of developers know this but you can actually play

151
00:13:33,840 --> 00:13:42,840
frame-by-frame on a video so let's let's just let's just open up a video I have

152
00:13:42,840 --> 00:13:48,840
here and you'll see that I have it paused here and if I use the period key

153
00:13:48,840 --> 00:13:53,440
or the comma so the period a little forward a frame and the comma will go

154
00:13:53,440 --> 00:13:57,040
back a frame so I can press period period period so you can see I go

155
00:13:57,040 --> 00:14:05,480
frame-by-frame and view what's going on now I didn't want to bring up anybody's

156
00:14:05,480 --> 00:14:10,680
any of the particular videos that I've seen and I've seen a lot of them where

157
00:14:10,680 --> 00:14:17,560
you could just tell from one frame you can see the file system is exposed the

158
00:14:17,560 --> 00:14:21,360
browser tabs are shown all sorts of stuff is shown in one frame and they

159
00:14:21,360 --> 00:14:28,040
don't even notice it you very easily press pause and then just use the period

160
00:14:28,040 --> 00:14:35,880
and comma to go frame by frame to view this sensitive information and there are

161
00:14:35,880 --> 00:14:40,880
channels that are dedicated not dedicated there are channels that are

162
00:14:40,880 --> 00:14:45,760
kind of like reaction channels and they will very often use this this

163
00:14:45,760 --> 00:14:49,760
frame-by-frame feature to look at stuff in the background and comment on it or

164
00:14:49,760 --> 00:14:54,480
you know look at what's going on you know and their tabs and all this other

165
00:14:54,480 --> 00:15:01,360
stuff and they'll just comment on it as part of their gimmick so it's not just

166
00:15:01,360 --> 00:15:06,200
you know malicious actors who know how to do it there's a lot of YouTube

167
00:15:06,200 --> 00:15:10,960
channels that just promote this this frame swapping which is fine it's a

168
00:15:10,960 --> 00:15:16,840
fantastic feature like I've I've used it for animations when I watch some really

169
00:15:16,840 --> 00:15:21,720
cool animations online and I want to see how they they did the tweening or

170
00:15:21,720 --> 00:15:26,360
something like that I can use the the comma and the period to go back and

171
00:15:26,360 --> 00:15:30,480
forth the frame to kind of see how they they did the tweening and it's really

172
00:15:30,480 --> 00:15:36,800
nice it's a really nice feature honestly it's just in the wrong hands and with

173
00:15:36,800 --> 00:15:44,360
experienced video creators you'll find that they you know malicious people view

174
00:15:44,360 --> 00:15:48,560
it or as though you know it's maybe they're not malicious but it's just

175
00:15:48,560 --> 00:15:51,000
information they shouldn't know and shouldn't have in their head it's

176
00:15:51,000 --> 00:16:01,280
information for your head so that's kind of my perspective on on all of that sort

177
00:16:01,280 --> 00:16:06,440
of stuff now there is one more thing that you need to be aware of and this

178
00:16:06,440 --> 00:16:11,280
one is a lot has caught a lot more in people's videos but sometimes they're

179
00:16:11,280 --> 00:16:21,000
not and that's notifications so you'll get notifications on phones and you'll

180
00:16:21,000 --> 00:16:27,160
get notifications on in on Windows so if it's on the phone it's a little bit more

181
00:16:27,160 --> 00:16:30,480
difficult but if the phones on the desk and the cameras pointed in such a way

182
00:16:30,480 --> 00:16:38,320
that they can see it it'll be very easy to kind of see you see information there

183
00:16:38,320 --> 00:16:42,800
maybe it's hard because in the background is blurry but still you

184
00:16:42,800 --> 00:16:50,160
should just put on is it busy or you know yeah I think it's like busy on your

185
00:16:50,160 --> 00:16:55,000
phone where you it doesn't present any notifications turn that guy on if your

186
00:16:55,000 --> 00:16:58,480
phone is gonna be in the video or if you're reviewing phones or anything like

187
00:16:58,480 --> 00:17:02,560
that just if it's on the screen on a table in the back a lot of people have

188
00:17:02,560 --> 00:17:07,840
tables on the side or they put their phones and yeah it's it's not the

189
00:17:07,840 --> 00:17:14,720
greatest so just turn on busy or put it face down either one works and on

190
00:17:14,720 --> 00:17:21,120
Windows you can use quiet hours and it is important that you click it twice or

191
00:17:21,120 --> 00:17:25,320
quite time I don't always called is port you click it twice to alarms only

192
00:17:25,320 --> 00:17:29,680
because there is one that shows important notifications which may be

193
00:17:29,680 --> 00:17:38,360
work or emails or things like that so it's pretty easy you just hit on the

194
00:17:38,360 --> 00:17:42,600
down here where the little speaker thing is and the this is from a laptop so the

195
00:17:42,600 --> 00:17:46,680
little battery and the Ethernet just click on that and you click on this moon

196
00:17:46,680 --> 00:17:51,080
icon twice if it's not there then just hit this little pencil and add it hit it

197
00:17:51,080 --> 00:17:56,440
twice go to alarms only you're not gonna get any notifications a lot of this may

198
00:17:56,440 --> 00:18:01,520
be redundant for people but I've seen a lot of technical people don't follow

199
00:18:01,520 --> 00:18:09,880
these and it's just information that people shouldn't see so that's my rant

200
00:18:09,880 --> 00:18:17,000
on that that bothered me a lot recently it's happened way too many times and I

201
00:18:17,000 --> 00:18:22,680
also have a friend he's he's goofy anytime I put up a video and I'd like

202
00:18:22,680 --> 00:18:29,520
alt-tab that I'm just sending him for you know I trust him and all that you

203
00:18:29,520 --> 00:18:33,400
know he'll send me a screenshot be like what's that that sort of stuff and it's

204
00:18:33,400 --> 00:18:39,000
like a single frame so it's it's just part of human nature to be very curious

205
00:18:39,000 --> 00:18:43,680
on what's on people's computers and desktops what's in there it's kind of

206
00:18:43,680 --> 00:18:50,360
like you know there's a back room and the door is cracked slightly open pretty

207
00:18:50,360 --> 00:18:54,960
much everybody yeah who's who's not boring is gonna be you know trying to

208
00:18:54,960 --> 00:19:01,200
see creep over there and kind of peek or maybe even just ask her outright so yeah

209
00:19:01,200 --> 00:19:09,120
it's just something I thought needed a PSA but hopefully you follow all those

210
00:19:09,120 --> 00:19:17,040
so now I'm gonna talk about programming so part two I guess this is I don't know

211
00:19:17,040 --> 00:19:24,960
what to call it I think we'll call it it's very it's not groundbreaking but

212
00:19:24,960 --> 00:19:31,400
I'll call it grapevine coding it's where you hear something about how to program

213
00:19:31,400 --> 00:19:40,880
and you kind of take it as law of programming so programming back in the

214
00:19:40,880 --> 00:19:45,280
past may have been closer to that where there are paradigms that you can tell

215
00:19:45,280 --> 00:19:50,480
each other and they would be pretty reliable at being fast efficient saving

216
00:19:50,480 --> 00:19:55,960
size all those sorts of things and those paradigms first of all we're still using

217
00:19:55,960 --> 00:20:02,080
ones from three years ago three decades you'll still run into programmers who

218
00:20:02,080 --> 00:20:10,960
ask you know about these very old problems and that no longer exist so you

219
00:20:10,960 --> 00:20:17,240
kind of hear it on the grapevine and you you base your code and and and how you

220
00:20:17,240 --> 00:20:23,680
design your code on it which is even worse so one of the first things I want

221
00:20:23,680 --> 00:20:31,880
to mention is premature optimization we've all heard it we've all had leads

222
00:20:31,880 --> 00:20:37,520
we've all had friends who have said it preemus premature optimization is the

223
00:20:37,520 --> 00:20:44,200
root of all evil and they're quoting some guys from you know 60 years ago or

224
00:20:44,200 --> 00:20:50,800
so and they're guys I respect like Donald Knuth is it Knuth? Donald Knuth? I

225
00:20:50,800 --> 00:20:58,760
don't know I have his art of coding series it's like a big stack of books he

226
00:20:58,760 --> 00:21:07,040
kind of repeated it and one thing we need to realize is that quote was from

227
00:21:07,040 --> 00:21:12,400
the time of assembly and if anybody's programmed in assembly you know exactly

228
00:21:12,400 --> 00:21:16,200
what I'm talking about and you know exactly what they're talking about when

229
00:21:16,200 --> 00:21:21,480
they say premature optimization is the root of all evil because in assembly it's

230
00:21:21,480 --> 00:21:26,720
as programmers we can count the clock cycles and we can think oh man I if I

231
00:21:26,720 --> 00:21:30,680
can shave off a clock cycle here and a clock here you know I could do a cool

232
00:21:30,680 --> 00:21:37,280
effect or something or I can add I can have extra performance and those were

233
00:21:37,280 --> 00:21:43,600
very dangerous because you would design pretty pretty ridiculous code the code

234
00:21:43,600 --> 00:21:50,760
would be completely unreadable even with comments for assembly code and it's just

235
00:21:50,760 --> 00:21:54,440
awful to work in a team where parts of code you just don't understand

236
00:21:54,440 --> 00:22:02,000
especially if they're using some kind of hack or anything like that so it's that's

237
00:22:02,000 --> 00:22:10,800
kind of the root of it now that's propagated itself into modern era and in

238
00:22:10,800 --> 00:22:17,360
the modern era people use it for high-level languages now of course over

239
00:22:17,360 --> 00:22:22,960
optimization some early over optimization is not helpful on a team

240
00:22:22,960 --> 00:22:28,600
but you should always think about optimization as you're designing the

241
00:22:28,600 --> 00:22:32,440
code as part of your design not over optimization not ever you can't even

242
00:22:32,440 --> 00:22:37,400
really you can't even count clock cycles in a high-level language but you can

243
00:22:37,400 --> 00:22:40,120
think about how things are going to interact how slow they're going to be

244
00:22:40,120 --> 00:22:47,600
and so you really don't want to get that premature optimization is a root of all

245
00:22:47,600 --> 00:22:54,720
evil as like a base you want to work from in any project that is that is not

246
00:22:54,720 --> 00:23:00,440
good advice for high-level languages now the reason I say that is because

247
00:23:00,440 --> 00:23:04,800
high-level languages are much more easy to become spaghetti code you start

248
00:23:04,800 --> 00:23:09,880
adding a bunch of libraries your classes become super intertwined and is just

249
00:23:09,880 --> 00:23:14,640
almost impossible to undo things once they've get way too set in stone

250
00:23:14,640 --> 00:23:20,560
especially on a project where there's timelines involved and you've got

251
00:23:20,560 --> 00:23:24,080
project managers you're not going to get time to go back and rip out that whole

252
00:23:24,080 --> 00:23:29,240
thing to redo it so you do need to optimize those things up front and you

253
00:23:29,240 --> 00:23:32,520
need to think about the optimization you don't want to over optimize it it

254
00:23:32,520 --> 00:23:37,680
shouldn't be something that supports every test case scenario it should be

255
00:23:37,680 --> 00:23:43,920
something that supports the desired scenario and maybe design in a way that

256
00:23:43,920 --> 00:23:49,400
can extend it at minimal effort something like the visitor pattern is a

257
00:23:49,400 --> 00:23:54,520
great pattern for that sort of thing where the business logic comes into the

258
00:23:54,520 --> 00:23:58,040
system and it works off of that and you can swap out the business logic very

259
00:23:58,040 --> 00:24:04,960
easily so you do want to optimize ahead of time and that does want that should

260
00:24:04,960 --> 00:24:07,960
be something in the back of your mind you shouldn't just hack things in to get

261
00:24:07,960 --> 00:24:12,400
them going get them going quick you will regret it and it will waste a lot of

262
00:24:12,400 --> 00:24:18,520
your time and a lot of everybody else's time who has to use it and just to kind

263
00:24:18,520 --> 00:24:25,560
of show where I got this from this is actually a pretty nice book so let me

264
00:24:25,560 --> 00:24:33,520
set up my overhead camera here so we can look at it first of all it's from this

265
00:24:33,520 --> 00:24:38,240
book I like no scratch press this is a nice book thinking low-level writing

266
00:24:38,240 --> 00:24:44,960
high-level it's it's a kind of a thick book I have their x86 assembly x64

267
00:24:44,960 --> 00:24:49,680
assembly and a couple others of their books because they're they're nice I

268
00:24:49,680 --> 00:24:55,200
don't read books from start to finish so at programming books I don't read

269
00:24:55,200 --> 00:25:03,880
programming books from start to finish so that's definitely kind of one thing

270
00:25:03,880 --> 00:25:08,520
to keep in mind



1
00:00:00,000 --> 00:00:11,720
Just a moment, I've got to set up this overhead camera. Let's see. Okay, pretty sure I got

2
00:00:11,720 --> 00:00:18,920
it set up here. Let me move my keyboard out of the way. Thinking low-level, writing high-level.

3
00:00:18,920 --> 00:00:27,200
I just want to show you kind of where I got this. I've kind of always thought this, but

4
00:00:27,200 --> 00:00:37,320
it was put nicely into words in this book here. Let's see if we can't get a little bit

5
00:00:37,320 --> 00:00:46,360
of a zoom. There we go. So it actually talks about this here. Let's see. Although it's

6
00:00:46,360 --> 00:00:55,600
often attributed to Donald Knuth, who popularized it, Tony Hoare, another fantastic computer

7
00:00:55,600 --> 00:01:02,280
scientist, who said, premature optimization is the root of all evil. This has been a rallying

8
00:01:02,280 --> 00:01:07,280
cry of software engineers for application performance until the very end of time. However,

9
00:01:07,280 --> 00:01:13,400
it did not say concern with application performance during the early stages of application development

10
00:01:13,400 --> 00:01:20,520
is the root of all evil. And that's kind of the important part there. It was in a time

11
00:01:20,520 --> 00:01:26,200
of counting clock cycles. If you've done assembly programming, like I said, it's very tempting

12
00:01:26,200 --> 00:01:31,200
to count clock cycles. And I've done that quite a few times, and it's always bit me

13
00:01:31,200 --> 00:01:38,400
in the butt. And the people I code with on that, they regretted it. They were upset at

14
00:01:38,400 --> 00:01:47,520
me. So that's the book. I highly recommend it. I wouldn't go, I don't know how much this

15
00:01:47,520 --> 00:01:53,200
book was. It was kind of expensive. It's like $50. I don't know what it is now. But maybe

16
00:01:53,200 --> 00:02:00,000
if you can pick up a used copy, thumb through it, it's a pretty nice book. I like the no

17
00:02:00,000 --> 00:02:12,520
scratch press books. They're pretty sweet. So I'll put that back down here. So that's

18
00:02:12,520 --> 00:02:23,080
my long-winded part of premature optimizations. And I agree with the book. So let me turn

19
00:02:23,080 --> 00:02:37,920
off this phone. Okay. So that's part one, premature optimizations. So now that we've

20
00:02:37,920 --> 00:02:49,840
said that part, I'm going to counter that a little bit. That isn't a free pass to over-optimize

21
00:02:49,840 --> 00:03:00,960
all the time. Here's another example of programming and doing premature optimizations. So this

22
00:03:00,960 --> 00:03:10,120
is an example of something I did in my C library for my game engine. I was doing UTF-8 strings.

23
00:03:10,120 --> 00:03:19,280
And in those strings, I kind of put it, I knew I could go online and check out how other

24
00:03:19,280 --> 00:03:23,640
people have dealt with getting the length of the strings and all that sort of stuff

25
00:03:23,640 --> 00:03:28,320
and validating the strings. And I went online and I saw that, oh, it has tons of if statements.

26
00:03:28,320 --> 00:03:39,960
It has like four if statements just inside of a loop to determine if the UTF-8 string,

27
00:03:39,960 --> 00:03:45,520
to figure out its length, how many characters are in it. And for me, I was like, well, branching

28
00:03:45,520 --> 00:03:56,760
is not very good. All that branching is going to cost you in the long run. So I set up for

29
00:03:56,760 --> 00:04:07,880
myself a solution to the problem. Okay. I had to set up my web pages there. But I set

30
00:04:07,880 --> 00:04:17,080
up what I thought was a solution to the problem, I should say. And it was not, it did work.

31
00:04:17,080 --> 00:04:28,600
It was indeed faster. So this is my website. I had a little UTF-8 thing here. And you can

32
00:04:28,600 --> 00:04:33,520
see that I don't use any if statements. It's all just shifting logic and multiplication

33
00:04:33,520 --> 00:04:39,120
and addition, which can vectorize. It's not vectorized here because I'm not going to assume

34
00:04:39,120 --> 00:04:48,200
people are going to turn on vectorization. But here it's set up and then I have a validation

35
00:04:48,200 --> 00:04:56,040
function below that. So when I go to, when I went to run it, you'll see that it did go

36
00:04:56,040 --> 00:05:03,480
faster. It was 1.4 times faster than the internet common, or my previous attempt, I should say.

37
00:05:03,480 --> 00:05:15,560
And I do have the internet common one somewhere as well. Let me double check here. Okay. Unfortunately,

38
00:05:15,560 --> 00:05:19,800
I don't have the previous one. I do have one that I worked on a little bit. It did have

39
00:05:19,800 --> 00:05:24,160
a couple of if statements in it. This was like my first attempt at messing with it.

40
00:05:24,160 --> 00:05:33,760
And that one was 1.6 times faster than the, I guess it's five cases in the common internet

41
00:05:33,760 --> 00:05:42,640
one. So you can see that I can, I got faster than even one that was faster than that. 1.4

42
00:05:42,640 --> 00:05:51,000
times faster than that. Now, one of the problems I had was as the string scaled and it repeated

43
00:05:51,000 --> 00:05:57,680
itself, the internet common one, which is the one with all of the if statements, wound

44
00:05:57,680 --> 00:06:05,840
up being faster than my implementation without any if statements inside of the loop. And

45
00:06:05,840 --> 00:06:11,640
that's very, you know, surprising for anyone that, you know, talks about branching being

46
00:06:11,640 --> 00:06:21,800
very slow. Now I could try and run it. I do have the updated version here. But my problem

47
00:06:21,800 --> 00:06:29,120
is that the benchmarking software or website that I'm using here stopped working today,

48
00:06:29,120 --> 00:06:35,200
I think. So let's try to run it. I'm just going to paste it in here and then let's use

49
00:06:35,200 --> 00:06:41,720
cling 14. That's the one I used for my C++ engine. I'm going to run the benchmark. I'm

50
00:06:41,720 --> 00:06:46,320
not going to make you wait for this. I'm going to pause and see if it breaks. Okay. Yep,

51
00:06:46,320 --> 00:06:52,200
it's still broken. But you can take my word on it. When it was a short string or a string

52
00:06:52,200 --> 00:06:59,240
of random characters, I would see that my implementation was a little bit faster or

53
00:06:59,240 --> 00:07:03,560
quite a bit faster depending on the scenario. But when it was a really long string of repeating

54
00:07:03,560 --> 00:07:13,200
characters, the one with many if else branches wouldn't work. And this isn't even the right

55
00:07:13,200 --> 00:07:19,960
one. It's supposed to be this one. Anyways, it doesn't matter. It doesn't work anyways.

56
00:07:19,960 --> 00:07:24,900
So there goes against the conventional logic. Of course, the reasoning for this is that

57
00:07:24,900 --> 00:07:32,720
whenever it's a repeating string, the CPU, and this is modern CPU, I'm assuming, that

58
00:07:32,720 --> 00:07:40,480
is running on these cloud servers that this is hosted on, it detected the pattern and

59
00:07:40,480 --> 00:07:50,160
it did the branch selection much more efficiently. The other alternative is that the compiler

60
00:07:50,160 --> 00:07:55,360
saw the pattern. And since it's a very common pattern for UTF-8, the compiler optimized

61
00:07:55,360 --> 00:08:02,160
the code to a better performing UTF-8 function in assembly code. And so the compiler is kind

62
00:08:02,160 --> 00:08:15,680
of in the way there. Or useful? Useful in my way for my test, but useful overall.

63
00:08:15,680 --> 00:08:24,440
So essentially that's one of the things about tribal knowledge. The tribal knowledge of

64
00:08:24,440 --> 00:08:29,880
this will go faster if you remove the branches is not always true. So you don't want to just

65
00:08:29,880 --> 00:08:35,080
remove if statements to make it faster. Now, I do use my version of UTF-8 because it's

66
00:08:35,080 --> 00:08:39,600
better in most scenarios and it looks nicer to me. I think it looks pretty. It's better

67
00:08:39,600 --> 00:08:47,800
in a bunch of if-else cases. But that kind of shows you that you really do need to test

68
00:08:47,800 --> 00:08:57,680
on your hardware. There's nothing beyond testing on your target hardware.

69
00:08:57,680 --> 00:09:03,760
Now I've talked a lot about kind of just general things of optimization early. Over-optimizing

70
00:09:03,760 --> 00:09:11,160
doesn't always work. But now I want to talk about ways that you can improve your code

71
00:09:11,160 --> 00:09:20,320
on any system that either has these features or some features they have to have, like memory

72
00:09:20,320 --> 00:09:27,640
stuff. But these are surefire ways to improve the performance of your code. They are, you

73
00:09:27,640 --> 00:09:34,840
know, kind of like magic bullets. Basically, it's hard to go wrong with them unless you

74
00:09:34,840 --> 00:09:42,560
really don't know what you're doing. The first one is turn on the MMX or AVX or SIMD or for

75
00:09:42,560 --> 00:09:56,840
Android turn on NEON with flags like in Clang I think on Linux it's minus M-A-V-X. On Windows

76
00:09:56,840 --> 00:10:02,640
you can set it in Visual Studio. But turn those on and the compiler itself is going

77
00:10:02,640 --> 00:10:08,400
to vectorize. And vectorization, if you don't know what it is, SIMD stands for simultaneous

78
00:10:08,400 --> 00:10:16,120
instruction, multiple data. Essentially, you can provide lots of numbers and it can run,

79
00:10:16,120 --> 00:10:24,920
say, an ADD instruction in one of, it's not a single clock cycle, but in one of its virtual

80
00:10:24,920 --> 00:10:36,160
clocks for that. And so it will run in one instruction. So, you're not always going to

81
00:10:36,160 --> 00:10:40,320
know exactly what to do. It will try to vectorize where it can. It'll do it pretty efficiently

82
00:10:40,320 --> 00:10:46,340
in the standard libraries. So you will get some magic performance even if it's a little

83
00:10:46,340 --> 00:10:52,600
bit out of turning on vectorization. You can code vectorization yourself and it's not that

84
00:10:52,600 --> 00:11:00,920
difficult. The part that's annoying is that Android NEON uses something different than

85
00:11:00,920 --> 00:11:09,280
the standard AVX, MMX stuff. So you do have to if else case some of those things. The

86
00:11:09,280 --> 00:11:20,120
other problem is that on desktops you have access to doubles, larger, like a 256 byte

87
00:11:20,120 --> 00:11:27,000
vector. Whereas in Android NEON, I think you're limited to 128 byte vector. So you can't use

88
00:11:27,000 --> 00:11:33,160
like doubles, I mean you can do doubles, but you can't do, say, four doubles all together.

89
00:11:33,160 --> 00:11:38,160
You can do two, which is basically four floats. So there are some gotchas on that, depending

90
00:11:38,160 --> 00:11:43,920
on your platform. So it is a little annoying to support both. But you can write your code

91
00:11:43,920 --> 00:11:49,000
for this. And I wrote my own math library for my game engine. So all the vector math

92
00:11:49,000 --> 00:11:56,640
and all the matrix math, the whole shebang, I wrote by hand in C. And I used SIMD instructions

93
00:11:56,640 --> 00:12:07,720
to make it faster on desktop and make it faster on Android. Any CPUs that support those simultaneous

94
00:12:07,720 --> 00:12:14,920
instructions. So that's one way that you can, it's like a little magic bullet sometimes.

95
00:12:14,920 --> 00:12:18,760
You won't see much performance at all. And other times you can get some pretty big performance

96
00:12:18,760 --> 00:12:28,560
based on what you're doing. The other kind of magic bullet for making things faster is

97
00:12:28,560 --> 00:12:35,000
caching a lot of stuff. So of course, access to memory is slow, but caching things that

98
00:12:35,000 --> 00:12:41,360
are complicated or big structures, you know, if you're reading a file from a disk, whether

99
00:12:41,360 --> 00:12:45,960
it's binary or text, you've got to go read the file, do some stuff with it, read the

100
00:12:45,960 --> 00:12:51,200
file again later on. I don't know when, how often you do this. But if you were to load

101
00:12:51,200 --> 00:12:56,160
that into memory and just hold it in memory, just hold more in memory and not have to access

102
00:12:56,160 --> 00:13:06,200
it from the network or from file systems or, you know, kind of just those just elsewhere,

103
00:13:06,200 --> 00:13:12,200
you will gain performance. And of course, don't overdo it. Don't put your, I mean, we

104
00:13:12,200 --> 00:13:17,760
do that now. I think Unreal does that. It loads basically everything you need or as

105
00:13:17,760 --> 00:13:23,160
much as possible onto the GPU in this case, so that it can access it really quick.

106
00:13:23,160 --> 00:13:32,200
It is a very common practice to load up your memory with stuff you're going to use. That

107
00:13:32,200 --> 00:13:36,440
can go for shaders, it can go for GPU stuff, it can go for CPU if you're just processing

108
00:13:36,440 --> 00:13:45,200
data. Loading up that stuff into memory, caching things. In fact, one of the things, one of

109
00:13:45,200 --> 00:13:49,640
the software that you'll use in web is called Memcached or Memcached, I don't know how to

110
00:13:49,640 --> 00:13:55,920
say it, I'm pretty sure it's Memcached, where you can save things in a local cache or even,

111
00:13:55,920 --> 00:14:00,760
not even a local cache, it could be a remote cache, but it's all in memory, so it's much

112
00:14:00,760 --> 00:14:06,560
faster than a remote database and reading from the database, which reads from file system,

113
00:14:06,560 --> 00:14:15,600
even with SSDs. So, caching stuff in memory, kind of a magic bullet if you do it right.

114
00:14:15,600 --> 00:14:21,360
Checking your memory alignment. Some platforms like Raspberry Pi 3 will actually crash if

115
00:14:21,360 --> 00:14:27,680
you don't align your memory. So, some platforms force you to do this. But Intel, for the longest

116
00:14:27,680 --> 00:14:34,240
time, does not force you to align your memory. And aligning your memory properly will improve

117
00:14:34,240 --> 00:14:41,000
your performance, not significantly, but it is a nice performance boost. Reading data

118
00:14:41,000 --> 00:14:46,640
into structures, writing data, holding data, transferring data between multiple objects

119
00:14:46,640 --> 00:14:50,600
or cloning your data, it's going to be much faster, not much faster, it's going to be

120
00:14:50,600 --> 00:14:57,480
faster if you align your data properly. So, I think compilers have the option to align

121
00:14:57,480 --> 00:15:04,240
the memory for you, but it's not that hard to put an alignment in your structure. In

122
00:15:04,240 --> 00:15:13,080
fact, if you're using like Vulkan or Raspberry Pi 3, you do have to align your data structures

123
00:15:13,080 --> 00:15:17,280
to use it. So, in Vulkan, whenever you're setting up all your structures that interact

124
00:15:17,280 --> 00:15:23,000
with the Vulkan API, you align that data, because when it goes through the GPU, it expects

125
00:15:23,000 --> 00:15:28,960
to have a very specific alignment. So, it's not that much work, but it can gain you some

126
00:15:28,960 --> 00:15:38,480
performance. I don't think it's worth the effort most of the time, but it is probably

127
00:15:38,480 --> 00:15:47,200
a good practice to align your data. And then, aggregate commonly accessed data. I'm sure

128
00:15:47,200 --> 00:15:53,000
everybody's heard about this. They've heard about dots in Unity or, you know, what is

129
00:15:53,000 --> 00:15:57,320
it called? Entity component systems, stuff like that, where you have a system and then

130
00:15:57,320 --> 00:16:03,120
you have entities as an array and it accesses them, multiple enemies to the system. And

131
00:16:03,120 --> 00:16:09,040
it goes through this flow of accessing linear data, and that's much faster than accessing,

132
00:16:09,040 --> 00:16:15,320
say like a linked list. With a linked list, you have an object over there, an object over

133
00:16:15,320 --> 00:16:20,160
there, who knows where they're at. The memory is virtualized, so who knows where they're

134
00:16:20,160 --> 00:16:27,880
actually at in the physical memory. So, if you use, and by the way, like a linked list

135
00:16:27,880 --> 00:16:34,400
inside of lists, for example, inside of C Sharp are vectors, which are internally arrays.

136
00:16:34,400 --> 00:16:42,360
So, I'm talking about linked lists, when the data is disconnected. So, having your data,

137
00:16:42,360 --> 00:16:51,980
especially frequently accessed data, that is relative to each other in consecutive memory.

138
00:16:51,980 --> 00:16:57,080
If you want to do memory pooling and then have a big chunk of memory, and then, you

139
00:16:57,080 --> 00:17:05,360
know, virtualize your own addresses within that space, and you want to, say, put your

140
00:17:05,360 --> 00:17:08,760
entity for your game object in there, and its components and all that stuff that it

141
00:17:08,760 --> 00:17:14,960
has to access, you can put it in there. If you have a set of entities that all do the

142
00:17:14,960 --> 00:17:20,480
same thing, but they have individual datas, but you want to update them collectively,

143
00:17:20,480 --> 00:17:25,960
consecutively, you can use that memory pooling to kind of put them all in this consecutive

144
00:17:25,960 --> 00:17:32,160
memory. And knowing your CPU is good for this, because if you know how much cache you have

145
00:17:32,160 --> 00:17:37,320
on the CPU, you can actually optimize for cache, so that it'll load in a big old chunk,

146
00:17:37,320 --> 00:17:41,360
and it'll just blow through it really fast, and then you don't have to worry so much about

147
00:17:41,360 --> 00:17:47,800
your access to memory being slow. And that's the bottleneck of pretty much most programs

148
00:17:47,800 --> 00:17:52,360
outside of file system access and that sort of stuff, network stuff. So, aggregate your

149
00:17:52,360 --> 00:18:03,680
data together. That's one easy way to surefire, make your program faster.

150
00:18:03,680 --> 00:18:08,080
So those are some things you do to have magic bullets to solve a little bit of performance,

151
00:18:08,080 --> 00:18:13,040
but you're not going to make huge gains out of that. You're going to make little tiny

152
00:18:13,040 --> 00:18:18,680
gains, and it could be fun doing that sort of stuff. So there's no magic bullet for doubling

153
00:18:18,680 --> 00:18:23,320
your speed. Usually that just means fixing your overall algorithm, your business logic

154
00:18:23,320 --> 00:18:32,280
and how it operates. So even quantifiable algorithms that, you know, you've tested

155
00:18:32,280 --> 00:18:38,120
two algorithms and you've quantified mathematically, and one algorithm is better than the other,

156
00:18:38,120 --> 00:18:42,880
does not mean that it's going to run faster than the other, unless it leaps and bounds

157
00:18:42,880 --> 00:18:47,640
faster. If it's slightly faster, it does not mean it's going to run faster. Like I said,

158
00:18:47,640 --> 00:18:52,400
the CPUs are very smart. They figure out branching, they figure out caching and all that sort

159
00:18:52,400 --> 00:18:58,120
of stuff. So you can have a quantifiable, faster algorithm that will get beat by a slower

160
00:18:58,120 --> 00:19:03,880
algorithm just because of the architecture. So I really liked, you know, Game Boy or Xbox,

161
00:19:03,880 --> 00:19:08,840
PlayStation 3, you know, all those computers, Commodore 64, where they all have the same

162
00:19:08,840 --> 00:19:16,680
hardware and that means it's known and so you can test it very easily. Our problem nowadays

163
00:19:16,680 --> 00:19:21,440
is we have tons of different CPUs, tons of different iterations of CPUs, even along,

164
00:19:21,440 --> 00:19:27,280
like if you said, I support only Intel CPUs, there's tons of different Intel CPUs, you

165
00:19:27,280 --> 00:19:32,840
know, released every year and you don't know which one your players are going to be using

166
00:19:32,840 --> 00:19:40,960
or your clients are going to be using. So you don't really want to test and really hyper,

167
00:19:40,960 --> 00:19:48,240
make the performance hyper fast on a specific CPU, aka your development machine, at the

168
00:19:48,240 --> 00:19:55,480
cost of flexible code or readable code or elegant code or any of that. So it's just

169
00:19:55,480 --> 00:20:00,320
something to keep in mind. If you are using a very well-known, specific set of hardware,

170
00:20:00,320 --> 00:20:06,800
usually game consoles, more power to you. Just knock out that performance on that CPU

171
00:20:06,800 --> 00:20:12,480
because it's a known CPU that you can, you're programming against. Everybody, everyone who's

172
00:20:12,480 --> 00:20:19,520
going to play your game on that device has that device. So that's, you can optimize in

173
00:20:19,520 --> 00:20:29,760
those scenarios and just go whole ham for that. So yeah, just test specific hardware.

174
00:20:29,760 --> 00:20:36,400
If you have minimum requirements, suggested requirements, test on those guys, test the

175
00:20:36,400 --> 00:20:41,680
performance. You may very well find that one performs better in one scenario and worse

176
00:20:41,680 --> 00:20:50,080
in another. So that's kind of the thoughts on optimization. Now I do want to wrap this

177
00:20:50,080 --> 00:20:59,520
up with a famous optimization and I've been asked about this optimization. You know, it's

178
00:20:59,520 --> 00:21:05,400
something that a lot of people know because it's a very popular one. And this is the inverse,

179
00:21:05,400 --> 00:21:18,240
the fast inverse square root. You know, it's a 30-year-old square root that they did for,

180
00:21:18,240 --> 00:21:25,800
was it Doom or Quake? It was probably Quake. I don't know. John Carmack made it but he

181
00:21:25,800 --> 00:21:30,000
got it from someone else. I'm like, I don't know the history. History is not important.

182
00:21:30,000 --> 00:21:36,160
The fact is you shouldn't be using this. This is a 30-year-old algorithm made for the machines

183
00:21:36,160 --> 00:21:43,200
of the time which didn't have branch prediction, for example. And they didn't have built-in

184
00:21:43,200 --> 00:21:52,120
signs or they didn't have built-in square roots. Nowadays, we have built-in square roots.

185
00:21:52,120 --> 00:21:55,240
We have built-in square roots for floats. We have built-in square roots for doubles

186
00:21:55,240 --> 00:22:04,440
and they are single instruction on the CPU. So it's not worth our time to implement 30-year-old

187
00:22:04,440 --> 00:22:13,400
algorithms and computers change often. And it's just one thing that I do see developers

188
00:22:13,400 --> 00:22:19,620
getting caught up on is some of these, some of this old knowledge that doesn't really

189
00:22:19,620 --> 00:22:25,160
apply anymore. So I've got a little thing here we can take a look at. So if we take

190
00:22:25,160 --> 00:22:30,880
a look here at this code, we're including math. It's just a little C file. And we're

191
00:22:30,880 --> 00:22:37,720
going to do the square root float, square root double. And I'm just going to put a break

192
00:22:37,720 --> 00:22:41,880
point here. This is debug mode. Nothing is optimized because otherwise it will strip

193
00:22:41,880 --> 00:22:49,200
out the stuff and I don't want to fight the optimizer to show an example of something.

194
00:22:49,200 --> 00:22:53,360
So we're going to run this and what we're going to do here, I already have it open,

195
00:22:53,360 --> 00:22:59,680
but you can go to debug, windows, disassembly to see the assembly code that's generated

196
00:22:59,680 --> 00:23:09,400
for this program. And if we just look at the disassembly here, we can see that we have,

197
00:23:09,400 --> 00:23:13,880
this is the C code and these are the functions that are set up for it. I don't know exactly

198
00:23:13,880 --> 00:23:18,400
what it's going to be when you optimize the code. It may even strip the square root based

199
00:23:18,400 --> 00:23:22,920
on the cons that are going in and all that sort of stuff. But anyways, you can see here

200
00:23:22,920 --> 00:23:29,560
it uses implementation of square root F here, which is going to be an internal function

201
00:23:29,560 --> 00:23:35,120
that does magic things. But what you can see here for the square root of double is that

202
00:23:35,120 --> 00:23:43,520
it is a single built in assembly instruction. Well, it's calling this function. And this

203
00:23:43,520 --> 00:23:48,840
function, the reason it's calling this function is that vendors can implement it how they

204
00:23:48,840 --> 00:23:55,600
want. Most of them are going to implement it. You can see this is using XMM by the way.

205
00:23:55,600 --> 00:24:03,480
Most of the vendors are going to implement it the way that is fastest. So CPU calls,

206
00:24:03,480 --> 00:24:10,560
it's going to be based on the architecture. But this is going to be way, way faster than

207
00:24:10,560 --> 00:24:16,920
the inverse square root function from 30 years ago. So do not use that. And don't use knowledge

208
00:24:16,920 --> 00:24:25,960
from 30 years ago. Use wisdom from 30 years ago. Generally how you work with teams and

209
00:24:25,960 --> 00:24:32,760
how you work with code and how you design code and think about how things interact.

210
00:24:32,760 --> 00:24:36,280
That sort of stuff is super valuable. Those guys did a lot of research mainly in those

211
00:24:36,280 --> 00:24:42,180
fields. They didn't optimize these little instructions. And that is the useful information

212
00:24:42,180 --> 00:24:49,840
for you. Not inverse square root or any particular algorithm. If an algorithm has been used for

213
00:24:49,840 --> 00:24:55,640
30 years, take a look at maybe making a new algorithm. Because there's a lot of stuff

214
00:24:55,640 --> 00:25:02,840
that gets added to CPUs. We have now artificial intelligence parts of our CPUs. We've got

215
00:25:02,840 --> 00:25:10,720
matrix stacked CPUs. We've got all kinds of new stuff that can use a different algorithm

216
00:25:10,720 --> 00:25:18,120
and perform much faster. Say whether it's distributed across multiple cores. Or maybe

217
00:25:18,120 --> 00:25:23,560
you even use the GPU to do the algorithm. Because we do have compute GPU now. Like compute

218
00:25:23,560 --> 00:25:32,440
shaders or CUDA. You can just write an algorithm that runs across a huge amount of cores and

219
00:25:32,440 --> 00:25:40,960
blow through things way faster now. So that's kind of my general advice on optimization.

220
00:25:40,960 --> 00:25:50,000
Don't over optimize. But do think about optimizing ahead of time. And don't stress out. Have

221
00:25:50,000 --> 00:25:55,400
fun while coding. Think about it. Think more about your overall design. Who you're working

222
00:25:55,400 --> 00:26:01,600
with. Whether you're working alone or not. And just think about those aspects of your

223
00:26:01,600 --> 00:26:05,440
coding. And you're going to have a wonderful experience. And you're going to be much happier.

224
00:26:05,440 --> 00:26:09,520
And you're not going to get caught up in all the fights on stack overflow or whatever people

225
00:26:09,520 --> 00:26:16,240
do on stack overflow these days. So, cool. That's basically it. If you guys have any

226
00:26:16,240 --> 00:26:23,480
suggestions on things to take a look at or think about or talk about or anything like

227
00:26:23,480 --> 00:26:29,400
that. This has been quite a lot of fun. So, yeah. Let me know if I missed anything. If

228
00:26:29,400 --> 00:26:34,720
I messed up anything. If I got any information wrong. You know, if things have changed or

229
00:26:34,720 --> 00:26:41,040
maybe I just misinterpreted something. Let me know and we can always pin the comment

230
00:26:41,040 --> 00:26:46,480
so that other people know too. So, bye for now.

231
00:26:46,480 --> 00:26:52,880
Hello. This is an amendment to the podcast. You can tell that it's a different day. Sun's

232
00:26:52,880 --> 00:26:58,400
out and everything. But I was going to sleep last night and I realized that I said 256

233
00:26:58,400 --> 00:27:05,920
bytes for SIMD instructions and 128 bytes for the NEON instructions for ARM. And I meant

234
00:27:05,920 --> 00:27:10,480
to say bits. So, I don't know why that bugged me. Clearing that one up. Second one, the

235
00:27:10,480 --> 00:27:17,400
one that actually bothered me was the system calls to the square root functions. And that's

236
00:27:17,400 --> 00:27:22,840
because we were in debug mode and it was getting late and I wasn't thinking about it. So, I

237
00:27:22,840 --> 00:27:32,120
have now set up a release mode demo here where we will see the x86 instructions for square

238
00:27:32,120 --> 00:27:36,840
roots. So, you can see I have to print them out so that it doesn't optimize my variables

239
00:27:36,840 --> 00:27:42,760
out. And then if we run this and check out our disassembly, it will be in reverse order.

240
00:27:42,760 --> 00:27:47,400
The key is going to be up here. But you see it calls the assembly instruction square root

241
00:27:47,400 --> 00:27:56,240
PD and then square root single signed or signed single. I don't know which one of the S's

242
00:27:56,240 --> 00:28:03,240
is signed and which one is singled. But there you go. That's the actual assembly instructions

243
00:28:03,240 --> 00:28:07,880
I was expecting to see. I was a little bit surprised when I didn't see them last night.

244
00:28:07,880 --> 00:28:15,040
But it's because I was in debug mode. I wasn't thinking. So, yeah. And that's basically my

245
00:28:15,040 --> 00:28:17,480
amendment. See you guys.




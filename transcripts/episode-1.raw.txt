hello and welcome back this is going to be uh I guess episode two well I start at zero for indexing right so this would
be episode one zero one um welcome to episode one of the podcast
um and I just saw recently that there was kind of an uptick in
uh people who are streaming and they hit alt tab or they have
they just have things on their screen that they shouldn't have you know um everything from like
home addresses web searches adult videos the websites
you know um and that sort of stuff just a lot of personal information
that is just going out there and it's kind of a it's kind of a
problem uh you know with people streaming a lot and exposing all this stuff and there's a lot of easy ways
to combat these problems especially on Windows Windows has a lot of tools for you to not fall prey to this
to this I don't know what to call it the these self-destructive problems and it could
be out of laziness or whatever else but I have some some thoughts on
how to solve that and just some things people can do when they're streaming and it's not even just streaming there's a
lot of people who record videos I've watched people who record videos and they think the the animations and the
things moving around is fast enough to not worry about people seeing their address uh you know on a maps location
or saying their private messages with their uh with their wife in this case that I'm
thinking of a wife or husband or whoever else so there's there's very easy things you can
do whenever you're recording whenever you're streaming on Windows that'll solve this so I'm going to start off with talking
about those things just some tools that you can use to to not fall prey to that and then the second part I'm going to
talk a little bit about programming mainly about optimizing and making your code a bit
faster and just things to think about I guess
so staying uh private while you're streaming one of the most common things
that people do is they alt tab and ALT tab is nice it allows you get through
things really quickly let me suggest to you alt Escape let's say that you have
two windows you can put the window that you want to kind of look at on the screen behind the game and put your
other stuff on the other monitor and you use alt escape to go to the background window and then
come back to foreground so it's kind of like going through them in that way it
just allows you to Simply switch between it basically sends the
current program to the back of the stack and the next one shows up so if there's only two you're just going to be swapping between the two
so that's just a quick alternative if you're kind of wanting that that
velocity of alt tab but of course we have lots of tabs we want to tab through them and we want to find the one that uh
we're interested in so the next thing that you'd want to do is virtual desktops
not many people I've seen through their streams or anything like that use Virtual desktops
they kind of just stick everything about them up on their primary window
so I like to use Virtual desktops to separate out this stuff and the great
thing about virtual desktops is that you can shut down your computer you can restart your computer and it'll come back up and you'll still have your
virtual desktop so you don't have to reset them up in fact here's a example
of what it looks like we have I have a primary desktop here and I got a podcast
desktop here you can guess which one I'm using right now the primary one is going to have you
know chats and that sort of stuff on it and then the podcast one is going to have podcast related things the great thing
about this is when you alt tab you're presented with just the programs
that are running on that desktop so in this way you don't have to do much you
can just set up these you can even give them a name as you saw just right click it hit rename there you go
um another problem that people have is browser tabs lots of lots of browser
tabs also when you type in the browser it shows history of your searches I don't want to know what kind of weird
things you search for but I am only human so when I see that pop up a little
nagging part of the back of my brain is like what's in there what are they what are they interested in
um not in a nefarious way but you know people you like to watch they have some information on things you wonder where
they're getting it from so it's very tempting for a lot of people people are
curious by nature and they're going to wind up looking through that stuff that pops up
especially if you have tabs search history all that sort of stuff um
so how do we solve this if you're a gamer you can use the steam browser I
think you press shift Tab and that'll open up the the steam overlay and you hit web browser and you can search on
stuff in there and that's a kind of an easier way for people that don't want to all Tab out or anything like that the
other one is to use browser sessions this is something I use quite often as
you can see I have a few sessions here so when you're in your browser there's a little icon in the top right and you
click on it and create you'll basically get this window with the sessions so you see I have my personal one I have one
that is explicitly for Google things only I have one that's for the podcast I
have one for Japanese stuff so you can guess that I'll be using
podcast one whenever I'm going through this and so the podcast uh they have their separate histories they have their
separate uh logins and you know data and plugins and everything else so
um separate out your separate separate out your browser stuff don't don't go
streaming with your main browser and you know Bank tabs open and all that sort of
stuff so yeah it's very easy just set these up you can you can you can decorate them you just hit the add
button you can add as many as you want very simple so that's kind of how you can separate
your browser how you can separate your desktops one of the problems that you'll have
with uh even if you separate out your desktops is you're going to have your
file system if you are a programmer and you're doing a programming video or a devlog or whatever
you're going to show your file system so and it's just inevitable you have a file
window open or you know you'll have uh files that you have to load up or
something like that so if you want to show off that stuff I think we all use git we all use you know subversion I
guess or per force or you know all the different kinds of the repositories so we can clone that
stuff over to a separate user account it's very easy to create a separate user
account I create one for family members I create them for um just random stuff I want to lock
myself out from or if I want to sandbox and like test around with things but you
can create a user and then do all your videos and you're streaming in that user you know if
you're a big game streamer you just create a uh this is my game streaming
account and you set a user and it has its own file system and you can lock it out of access from your main file system
so in that way you can prevent showing off your files whatever files you may
have um you know Court subpoenas or whatever yeah they they'll now be kind of Hidden
Away especially if you use the preview I sometimes use preview instead of
Explorer and you know you accidentally click on something it'll show you preview on the right and you don't want that going up on your stream or you know
up in your video and you didn't notice so creating a user account super easy
you just go into your settings you look for accounts and there's other user
accounts right here you just click add account very easy I don't think you have to have a Microsoft account for this for
these you can add it as a family member I don't know just add an account and it's very simple and that'll make it so
that you can separate out your file system and this will also make it so
that you don't need virtual desktops or have to make different browser stuff so this is just another Vector of attack
for adding you know not hiding but um you know not not displaying your
goods to the world there's a lot of important stuff on our computers and we have a lot of computers with a lot of
stuff strung around that we don't even notice especially when we're clicking around real fast and a lot of people
when they edit their videos they'll just load up their video and they'll skip ahead and you'll just miss those flashes
of frames that pop up with sensitive information so please use user accounts
if you need to protect your file system and those sort of things
so another kind of thing that you can do
is Windows sandbox unfortunately you need to have Windows Pro your bios has to allow for virtualization you need to
have it on in your bios and I think you need to have hyper-v set up so there's a lot of prerequisite
prerequisites to this and it may cost money if you don't have Windows Pro so this is kind of for the other people
that have Windows Pro and and all the virtualization enabled
and this one it's very simple you have apps and features just search features
it'll show up apps and features here and then you'll have a list of features I suggest you turn on
Windows subsystem for Linux as well if you're a developer and if you're watching this you probably are so turn
that guy on um if you don't already anyways Windows sandbox is right there you turn that on
restart your computer you'll be good to go and I guess I can
um I can show sandbox another problem I had with sandbox is once I installed it
I could type in sandbox and it doesn't show up in all my apps so I actually have to go and uh
go to all apps and then scroll all the way down to the W I'm actually going to pin it pin to
start you'll find in there just pin it or open it from from that
and that will open up this Windows sandbox and you'll see that it's just a
regular old windows looking instance I think I can scale this down so that it'll fit on the screen here
there we go so you'll see it looks like a regular Windows instance you can set up a
configuration file so that this can have access to certain folders when it launches which is nice you can make it
run programs at startup which is also nice if you want to install stuff that sort of thing and then of course
you can copy and paste from your primary desktop over into here so you can kind of set up your windows sandbox
to present something or anything like that and this is a nice way to not have to make a user and also it's a nice way
to clean out stuff if it's temporary and you're just showing off something and you don't want to keep all those files
and it's it's just a waste of space and you don't have to clean them up yourself
using the windows sandbox is cool because it destroys everything that's in
its session of course it doesn't destroy the linked folders but if you put files and stuff in here on the desktop or in
its own file system that's not the linked folders it will destroy them which is great especially if you're
let's say that you're showing off something in your program and it installs or whenever you build it
it makes like a makes like 30 gigs of files of assets or something it's really
nice to have it in a sandbox that you just close it and not worry about it it's just gone once you hit that X and
you'll see are you sure you want to kill sandbox yeah
option for you if you're not interested in
having people see all of your goods now I kind of did want to show
what happens what people do inside of YouTube If you don't know this um you know other web players have this
and you probably do know this I'm sure a lot of developers know this but you can actually uh
play frame by frame on a video so let's let's just
let's just open up a a video I have here
and you'll see that I have it paused here and if I use the period key or the comma so the period will go four
to frame and the comma will go back a frame so I could press period period period so you can see I go frame by
frame and View what's going on
now I didn't want to bring up anybody's any of the particular videos that I've seen and I've seen a lot of them where
you could just tell from one frame you can see the file system is exposed the
browser Tabs are shown all sorts of stuff is shown in one frame and they don't even notice it
um you very easily press pause and then just use the period and comma to go
frame by frame to view the sensitive information and
um there are channels that are dedicated not dedicated there are channels that
are kind of like reaction channels and they will very often use this this frame
by frame feature to look at stuff in the background and comment on it or you know look at what's going on you know in
their tabs and all this other stuff and they'll just comment on it as part of their their gimmick
so it's not just you know malicious actors who know how to do it there's a
lot of YouTube channels that just promote this this Frame swapping which is fine it's a fantastic feature like
I've I've used it for um animations when I watch some really cool animations online and I want to see
how they they did the tweening or something like that I can use the the comma and the period to go back and
forth a frame to kind of see how they they did the tweening and it's really nice it's a really nice feature honestly
it's just in the wrong hands um and with inexperienced video creators
you'll find that the you know malicious people view it or they'll you know it's maybe they're not
malicious but it's just information they shouldn't know and shouldn't have in their head it's information for your head so
that's kind of um my perspective on on
all of that sort of stuff now there is one more thing that you need to be aware
of and this one is a lot has caught a lot more in people's videos but
sometimes they're not and that's notifications so you'll get notifications
on phones and you'll get notifications on uh in on windows so if it's on the
phone it's a little bit more difficult but if the phone's on the desk and the camera is pointed in such a way that they can see it
um it'll be very easy to kind of see see information there maybe it's hard
because in the background it's blurry but still you should just put on uh is
it busy or uh yeah I think it's like busy on your phone where you it doesn't present any
notifications turn that guy on if your phone is going to be in the video or if you're reviewing phones or anything like that
just if it's on the screen on a table in the back a lot of people have tables on the side or they put their phones and
yeah it's it's not the greatest so just turn on
busy or put it face down either one works and on Windows you can use quiet hours
and it is important that you click it twice or quiet time I don't know what
it's called it's important you click it twice to alarms only because there is one that shows important notifications
which maybe work or emails or things like that so
it's pretty easy you just hit on the down here where the little speaker thing
is and the uh this is from a laptop so the little battery and the ethernet just click on that and you click on this Moon
icon twice if it's not there then just hit this little pencil and add it hit it twice go to alarms only you're not going
to get any notifications a lot of this may be redundant for people but I've seen a lot of technical
people don't follow these and it's just information
um that people shouldn't see so that's my rant on that that bothered
me a lot um recently it's happened way too many times and I also have a friend he's he's
goofy anytime I put up a video and I like all tab um that I'm just sending him uh for you
know I trust him and all that you know he'll send me a screenshot be like what's that that sort of stuff and it's
like a single frame so um it's it's just part of human nature to be very curious on what's on people's
computers and desktops what's in there it's kind of like you know there's a back room and the door is cracked
slightly open um pretty much everybody who's who's not boring is going to be you know trying to
see creep over there and kind of peek or maybe even just ask her outright so
um yeah it's just something I thought needed at PSA
but hopefully you follow all those so now I'm going to talk about programming so part two I guess
this is I don't know what to call it I think uh we'll call it it's it's very
[Music] um is not groundbreaking but I'll call it Grapevine coding it's where you hear
something about how to program and you kind of take it as law of
programming so programming back in the past may have
been closer to that where there are paradigms that you could tell each other and they would be pretty reliable at
being fast efficient saving size all those sorts of things and those
paradigms first of all we're still using ones from three years ago three decades
you'll still run into programmers to ask you know about these very old problems
and that no longer exist so you kind of hear it on the Grapevine
and you you baste your code and and and uh how you design your code on it which
is even worse so one of the first things I want to
mention is uh premature optimization we've all heard it
we've all had leads we've all had friends who have said it previous premature optimization is the root of
all evil and they're quoting some guys from you
know 60 years ago or so uh and they're guys I respect like Donald knuth is it
knuth Donald news I don't know um I have his art of coding series it's
like a big stack of books um he kind of uh repeated it and one thing
we need to realize is that quote was from the time of assembly
and if anybody's programmed in assembly you know exactly what I'm talking about and you know exactly what they're
talking about when they say premature optimization is the root of all evil because an assembly it's as programmers
we can count the clock cycles and we can think oh man if I can shave off a clock
cycle here and a clock here you know I could do a cool effect or something or I can add I can have extra
performance and those were very dangerous because you would design uh
pretty pretty ridiculous code the code would be
completely unreadable even with comments for for assembly code and uh it's just
awful to work in a team where parts of code you just don't understand especially if they're using some kind of
hack or anything like that so it's
that's kind of the root of it now that's propagated itself into
modern era and in the modern era people use it high level languages now
of course over optimization some early over optimization is not
helpful on a team but you should always think about optimization as you're
designing the code it's part of your design not over optimization not every you can't even really you can't even
count clock Cycles in a high level language but you can think about how things are going to interact and how
slow they're going to be and so you really don't want to get that premature
optimization is the root of all evil as like a base you want to work from in any
project that is that is not good advice for high-level languages now
the reason I say that is because high level languages are much more easy to become spaghetti code you start adding a
bunch of libraries your classes become super intertwined and is just almost
impossible to undo things once they get way too set in stone especially on a
project where there's timelines involved and you've got project managers you're
not going to get time to go back and rip out that whole thing to redo it so you do need to optimize those things up
front and you need to think about the optimization you don't want to over optimize it it shouldn't be something that supports every test case scenario
it should be something that supports the desired scenario
and maybe design in a way that can extend it at minimal effort something
like the visitor pattern is a great pattern for that sort of thing where the
business logic comes into the system and it works off of that and you can swap out the business logic very easily
so you do want to optimize ahead of time and that does one that should be
something in the back of your mind you shouldn't just hack things in to get them going get them going quick you will
regret it and it will waste a lot of your time and a lot of everybody else's time who
has to use it and just to kind of show where I got this from this is actually a
pretty um nice book so let me set up my
my overhead camera here so we can look at it first of all
it's from this book I like no scratch press this is a nice book thinking low-level writing high level
um it's it's a kind of a thick book I have their x86 assembly x64 assembly and
a couple others of of their books because they're they're nice I don't read books from start to finish
so at programming books I don't read programming books from start to finish so that's uh definitely kind of
one thing to keep in mind uh just a moment I'm
I've got to set up this overhead camera let's see
okay pretty sure I got it set up here let me move my keyboard out of the way
thinking low-level writing high level I just want to show you kind of where I got this uh
I've I've kind of always thought this um but it was put nicely into words
in this book here let's see if we can't get a little
bit of a zoom there we go so it actually talks about this here
um let's see although it's often attributed to Donald knuth who popularized it Tony
another fantastic computer scientist
um who said premature optimization is root of all evil this has been a rallying Cry
of software Engineers for application performance until the very end of time however you did not say concern with
application performance during early early stages of application development as a real quality evil and that's kind
of the important part there um it was in a time of counting clock
Cycles if you've done assembly programming like I said it's very tempting to count clock cycles and I've
I've done that quite a few times and it's always bit me in the butt and the people I I code with on that
um they regretted it they were upset at me so uh that's the book I highly recommend it
I wouldn't you know go I don't know how much this book was
uh I was kind of expensive it's like fifty dollars I don't know what it is now but maybe if you can pick up a used
copy um and thumb through it it's a it's a pretty nice book I like I like the no
scratch uh press books they're pretty pretty sweet so you know put that back down here
so that's uh my long-winded uh
part of premature optimizations and I agree with the book so uh let me turn
off this phone okay so
that's uh that's part one premature optimizations so
now that we've said that part I'm going to uh
counter that a little bit that isn't a free pra a free pass to over optimize
all the time here's another example of
programming and doing premature optimization so I this is an example of something I did in
my C library for my game engine I was doing utf-8
strings and in those strings I I kind of
put it I knew I could go online and check out uh how other people have have dealt with
getting the length of the strings and all that sort of stuff and validating the strings and I went online and I saw
that oh it has tons of if statements it has like four if statements just inside of a loop to determine if
um this is a UTF if the utf-8 string oh to
figure out its length how many characters are in it and for me I was like well branching isn't is not very
good all that branching um is going to cost you in the long run
so I've I set up for myself a uh
solution to the problem okay I had to set up my my web pages
there but I set up what I thought was a solution to the problem I should say
and uh it was not it did work
um it was indeed faster so this is uh my website I had a little
utf-8 thing here and you can see that I don't use any if statements it's all
just shifting logic and multiplication in addition which you can vectorize it's
not vectorized here because I'm not going to assume people are going to turn on vectorization but
here it's set up and then I have a validation function below that
so when I go to uh when I want to run it
you'll see that it did go faster it was 1.4 times faster than the internet uh common uh or my previous attempt I
should say and I do have the internet common one
somewhere as well let me double check here
okay unfortunately I don't have the previous one I do have one that I worked on a little bit it did have a couple of
if statements in it this is like my first attempt at messing with it and that one was 1.6 times faster than the
uh I guess it's five cases in the common internet one
so uh you can see that I can I got faster than even one that was faster
than that 1.4 times faster than that now one of the problems I had was as the
string scaled and it repeated itself the internet common one which is the one
with all of the if statements wound up being faster than my implementation without any if
statements inside of the loop and that's very you know surprising for for anyone that you know talks about
branching being very slow now I could try and run it uh
I do have the updated version here but my problem
is that the benchmarking software or website that I'm using here
um stopped working today I think so let's try to run it I'm just going to paste it in here and then
[Music] um let's use cling 14 that's the one I use for my C plus plus engine I'm going to
run a benchmark um I'm not going to make you wait for this I'm going to pause and see if it breaks
yep it's still broken but you can take my word on it when it was a short string
or a string of random characters I would see that my implementation was a little
bit faster are quite a bit faster depending on the scenario but when it is a really long
string of repeating characters the one with many if else branches uh
it wouldn't work and this isn't even the right one uh it's supposed to be this one anyways
doesn't matter it doesn't work anyways so there goes against the conventional logic of course the reasoning for this
is that whenever it's a repeating string the CPU and this is modern CPU I'm
assuming that is running on these Cloud servers that this is hosted on it detected the pattern
um and it did the branch selection uh
much more efficiently the other alternative is that the compiler saw that the saw the pattern and since it's
a very common pattern for utf-8 the compiler optimized the code to a better performing utf-8
function in assembly code and so the compiler is kind of in the way there
or useful useful in my way for my test but useful
overall so so essentially that's one of the things
about you know tribal knowledge the tribal knowledge of this will go faster if you move the
branches is not always true so you don't want to just remove if statements to
make it faster now I do use my version of utf-8 because it's better in most scenarios and it looks nicer to me I
think it looks pretty it's better in a bunch of FL cases um but that kind of shows you that you
really do need to test on your Hardware
uh the that's there's nothing Beyond testing on your target Hardware
um now I've talked a lot about kind of just general things of optimization early over optimizing doesn't always
work um but now I want to talk about ways that you can improve your code
um on any system uh that you know either has these features or
uh some features they have to have like memory stuff but
these are ways these are Surefire ways to improve the performance of your code they are kind of like Magic Bullets uh
basically it's hard to to go wrong with them unless you really don't know what you're doing
um the first one is turn on the MMX or AVX or CMD or for
Android turn on neon with flags like uh in
clang I think is on Linux it's minus AE minus M AVX on Windows
um you can send them Visual Studio but turn those on and the compiler itself is
going to vectorize and vectorization if you don't know what it is simd stands
for simultaneous instruction multiple data essentially you can
provide lots of numbers and it can run say an ad instruction
and and one of it's not a single clock cycle but you know in uh one of its you
know virtual clocks for that and it will run in one instruction uh so
I'm always going to know exactly what to do it we'll try to vectorize where it can it'll do it pretty efficiently in
the standard libraries so you will get some magic performance even if it's a
little bit out of turning on vectorization you can code vectorization yourself and
it's not that difficult um the the part that's annoying is that Android neon uses something different
than you know the standard um like AVX MMX stuff so you do have to
like if else case some of those things the other problem is that on desktops
you have access to um like doubles larger uh like a 256 byte
vector whereas in Android neon I think you're limited to 128 byte Vector so you
can't use like doubles I mean you can do doubles but um you can't do say four doubles all together you can do two
which is basically four floats so there are some gotchas on that depending on your platform so it is a little Annoying
to support both but you can write your your code for this and I I wrote my own
math library for my game engine so all the vector math and all the Matrix math the whole shebang I wrote by hand in C
and I used uh simd instructions to make it faster on desktop and make it faster
on Android um any any uh CPUs that support that
those simultaneous instructions so that's one way that you can it's like
a it's like a little magic bullet sometimes you won't see much performance at all and other times you can get some
pretty big performance based on what you're doing the other uh kind of Magic Bullet for
making your making things faster is uh caching a lot of stuff so of
course access to memory is slow but caching things that are complicated or
big structures you know if you're reading a file from a disk whether it's binary or text you got to go read the
file do some stuff with it read the file again later later on I don't know when how often you do this but if you were to
load that into memory and just hold it in memory just hold more in memory and not have to
access it from the network or from file systems or you know
kind of just those just elsewhere you will gain performance and of course
don't overdo it don't put your I mean we do that now I think unreal does that
it loads basically everything you need or as much as possible on to the GPU in
this case so that it can access it really quick
it is a very common practice to load up your your memory with stuff you're going to use then go for shaders you can go
for GPU stuff and go for CPU if you're just processing data um loading up that stuff into memory
caching things in fact uh one of the things one of the software that you'll
use in web is called memcached or memcache D I don't know how to say I'm pretty sure it's memcached
where you can save things in a local cache or even not even a local cache it
could be a remote cache but it's all in memory so it's much faster than a remote
database and reading from the database which reads from file system even with ssds so
caching stuff in memory kind of a Magic Bullet if you do it right um checking your memory alignment some
platforms like Raspberry Pi 3 will actually crash if you don't align your
memory so some platforms force you to do this but Intel for the longest time does
not force you to align your memory and aligning your memory properly will improve your performance not
significantly but it is a nice performance boost reading data into structures writing
data holding data transferring data between multiple objects or cloning your data it's going to be much faster not
much faster it's going to be faster if you align your data properly so
I think compilers have the option to align the memory for you um but it's not that hard to put an
alignment in your structure in fact if you're using like Vulcan or Raspberry Pi
3 you do have to align your data structures um to use it so in Vulcan whenever
you're setting up all your structures that interact with the the Vulcan API you align you align that data because
when it goes to the GPU it expects to have a very specific alignment so it's it's not that much work but it
can gain you some performance I don't think it's worth the effort most of the time
but if it can it is probably a good practice to align your data
and then aggregate commonly accessed data I'm sure everybody's heard about
this they've heard about dots in unity or you know what is it called entity
component systems stuff like that where you have a system and then you have engine uses an array and it accesses them
multiple enemies through the system and it goes It goes through this flow of accessing linear data and that's much
faster than accessing say like a linked list with a linked list you have
uh object over there an object over there who knows where they're at they could be the memory is virtualized so who knows
where they're actually uh in the physical memory so uh if you use uh and by the way like
link list inside of lists for example inside of C sharp or vectors which are
internally arrays so the I'm talking about linked to lists so when the data is disconnected
so having your data especially frequently access data that is relative
to each other and can in consecutive memory if you want to do memory pooling and
then have a big chunk of memory and then you know virtualize your own uh
addresses within that space and you want to say put a
your entity for your game object in there and its components and all that stuff that it has to access uh
you can put it in there if you if all if you have a set of entities that all do the same thing but they have individual
datas but you want to update them collectively consecutively you can use
that memory pooling to to kind of put them all in this consecutive memory and knowing your CPU is good for this
because if you know how much cash you have on on the CPU you can actually optimize for cash
so that it'll load in a big old chunk and it'll just blow through it really fast and then you don't have to worry so
much about your access to memory being slow and that's the bottleneck of pretty
much most programs outside of file system access and that sort of stuff Network stuff so aggregate your data
together that's that's a one of one of one easy way to Sure Fire
um make your program faster so those are some things you do to have
Magic Bullets to solve a little bit of performance but you're not going to make huge gains out of that you're going to make little tiny gains and it could be
fun doing that sort of stuff so there's no magic bullet for like doubling your speed usually that just means fixing
your overall algorithm your business logic and how it operates so even quantifiable algorithms that you
know you've you've tested two algorithms and you've Quantified mathematically now one algorithm is better than the other
does not mean that it's going to run faster than the other unless it's a you know Leaps and Bounds faster it's
slightly faster does not mean it's going to run faster like I said um the CPUs are very smart they figure
out branching they figure out caching and all that sort of stuff so you can have a quantifiable faster algorithm
that will get beat by slower algorithm just because of the architecture so I really liked you know Game Boy or
Xbox PlayStation 3. you know all those computers Commodore 64 where they have they all have the same Hardware
and that means it's known and so you can test it very easily
our problem nowadays is we have tons of different CPUs tons of different iterations of CPUs even along like if
you said I support only Intel CPUs so there's tons of different Intel CPUs you
know released every year and you don't know which one your players are going to
be using or your clients are going to be using so you don't really want to test
and really hyper make make the performance hyper fast on a specific CPU
AKA your development machine at the cost of flexible code or readable
code or elegant code or any of that so it's just something to keep in mind if
you are using a very well-known specific set of Hardware usually game consoles
more power to you just knock out that performance on that CPU because it's it's a known CPU that you can you're
programming against everybody everyone who's going to play your game on that device has that device so
that's you can optimize in those scenarios and just go whole hand for
that um so yeah just test specific Hardware
um if you have minimum requirements uh suggested requirements test on those
guys test the performance you may very well find that one performs better in
one scenario worse than another so that's that's kind of the thoughts on
optimization now I do want to wrap this up with a famous optimization and I've I've been
asked about this optimization um you know it's it's something that a lot of people
know because it's a very popular one and this is the inverse the fast inverse
square root you know it's a it's a 30 year old square root uh
that they did for uh
was it Doom or Quake it's probably Quake uh I don't know um
John Carmack said made it but he got it from someone else or something like I don't know the history history is not
important the fact is you shouldn't be using this this is a 30 year old algorithm
made for the machines of the time which didn't have Branch prediction for
example and they didn't have built-in signs or they didn't have built-in
you know built-in square roots nowadays we have built-in square roots
we have built-in square roots for floats we have built-in square roots for doubles and they are single instruction on the CPU so it's
it's not worth our time to Implement 30 year old algorithms and it
computers change often and uh it's just one thing that I do see developers
getting caught up on is some of these some of this old knowledge that doesn't
really apply anymore so I've got a little thing here we can take a look at so if we take a look here at this code
we're including math it's just a little C file and we're going to do the square
root float square root double and I'm just going to put a breakpoint here this is debug mode nothing is
optimized because otherwise it'll strip out stuff and I don't want to I don't want to fight the optimizer to
to show an example of something so we're going to run this and what we're going to do here I already have it
open but you can go to debug Windows disassembly to see the the assembly code
that's generated for this program and if we just look at the disassembly here
we can see that we have this is the C code and these are the
functions that are set up for it I don't know exactly what it's going to be when you optimize the code it may even strip
the square root based on you know the consts that are going and all that sort of stuff but anyways
uh you can see here it uses implementation of square root F here
which is going to be an internal function that does magic things but what you can see here for the square root of
double is that it is a single built-in assembly instruction
well it's calling this function and this function the reason it's calling this
function is that vendors can implement it how they want most of them are going to implement you
can see this is using xmm by the way most of the vendors are going to implement it uh
the way that is fastest so CPU calls it's going to be based on the
architecture but this is going to be way way faster than the inverse square root
function from 30 years ago so do not use that and don't use Knowledge from 30 years ago
use wisdom from 30 years ago um you know generally how you work with
teams and I work with code and how you design code and think about how
things interact that sort of stuff is super valuable those guys did a lot of research mainly in those fields they
didn't optimize these little instructions um and that is the useful information for
you not inverse square root or any particular algorithm
if an algorithm has been used for 30 years take a look at maybe making a new
algorithm because there's a lot of stuff that gets added to CPUs we have now you know artificial intelligence parts of
our CPUs we've got Matrix you know stacked CPUs we've got all kinds of new
stuff that can use a different algorithm and perform much faster say whether it's
distributed across multiple cores or maybe you even
use the GPU to do the algorithm because we do have compute GPU now computiators
or Cuda you can just write an algorithm that runs across a huge amount of cores
and blow through things way faster now so that's kind of my general advice on
optimization don't over optimize but do think about optimizing ahead of time and
don't uh you know don't stress out have fun while coding think about it think
more about your overall design who you're working with whether you're working alone or not
and just think about those aspects of your coding and you're going to have a
wonderful experience and you'll be much happier and you're not going to get caught up in all the fights on stack Overflow or whatever people do on stack
Overflow these days so cool that's that's basically it um if you guys have any suggestions on
things to take a look at or think about or talk about or anything like that this is this has been
quite a lot of fun um so yeah let me know if I missed anything if I messed up anything if I
got any information wrong uh you know if things have changed or maybe I just
misinterpreted something uh let me know and we can always pen the comment so
that other people know too so bye for now
hello this is an amendment to the podcast uh you can tell that it's a different day sun's out and everything
um but I was going to sleep last night and I realized that I said 256 bites for some D instructions and 128 bytes
for the neon instructions for arm and I meant to say bits so I don't know why
that bugged me clearing that one up second one the one that actually bothered me was the system calls
um to the square root functions and that's because we're in debug mode and it was
getting late and I wasn't thinking about it so I have now set up a release mode demo here
where um we will see the x86 instructions for square roots so you can say I have to
print them out so that it doesn't optimize my variables out and then if we run this and check out
our disassembly it'll be in reverse order the queue is going to be up here but you see it calls the assembly
instruction square root PD and then a square root uh
single signed or signed single I don't know which this is assigned and which one's singled
but there you go that's um that's the actual assembly instructions I was expecting to
see yeah I was a little bit surprised when I didn't see him last night but it's because I was in debug mode I
wasn't thinking um so yeah and uh that's basically my
Amendment see you guys
